<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Live2D插件介绍]]></title>
    <url>%2F30Lived2d_for_unity%2F</url>
    <content type="text"><![CDATA[本文介绍如何在Unity中使用二次元风格的Live2D 。 在一些博客上会遇到网页宠物挂饰，大部分是比较老旧的flash效果，但是现在有个蛮不错的新技术也实现了这个效果，这就是Live2D插件。 当然它不仅仅只用在博客上当挂饰，现在那些游戏登陆界面、或者手机app打开缓冲界面，经常会有能动的人物视觉，好多其实都是用该插件实现的！ 这里放一下两个下载链接： 2.1SDK下载指导文档 3.0unitypackage包下载指导文档 请先根据上面链接的教程，对应去下载SDK包。当然也可以去github下载最新包。在GitHubPage中，也刚好有人开源做这个插件的挂饰效果，已经集成在hexo中了。在我置顶博文中，底部的几个链接都有提到这个使用教程。本文只简单根据Unity中使用的情况来介绍该插件。 教程网页很人性化，是有中文和英文版本的，图文并茂，虽然部分链接点开需要VPN。这里就不讲复杂的怎么做模型，怎么应用等等。只在下载的两个包的基础上进行简单分析。 如果不会VPN，unitypackage包不要也行，它只是多了部分功能的集成而已（json转AnimationClip功能 等等其他好多功能的集成）。简单的接触，从官网主页下载的2.1sdk包就能正常运行了。 在sample里面是几个使用例子。每个都能独立正常运行的。 新建工程 可以新建工程，复制这些需要的东西来处理。这里也提一下老版本，如果识别不了dll，需要拖出来外面，然后使用面板上的Import new asset重新导入。 代码部分就不讲解了，这里简单提一下它的流程吧。 运用 这里是建了一个透明的背景材质，然后通过脚本来Load模型，并贴上去。Load函数在示例程序里面也有了，LAppModelProxy类。就是传model.json的地址给它，然后它找到这个文件后，解析，根据文件里面的记录，去找对应的其他信息：找模型、表情动作参数、声音等等。 示例程序这里的动画效果比较少，实际上，在unitypackage包里面就可以看到，是和骨骼动画一样，每一个关节都可以运动的！ 这里是记录播放该动画时，运行的时间fade，以及变动的键值。 expressins文件夹的4个动画效果，只是其中抽出来的示例动画，实际上只要我们想到，都可以编出来，然后加进去。2.1版本的还是读json，但是官方提倡使用动画机，在3.0就建议直接使用动画机来完成动画的编制了。原理都是找到对应的key，传递新value。就是多了一层解析封装，让动画机能直接调用并修改key的value。 这里可以自己封装，在motions里面可以提取key，然后包装，调用L2DMotionManager的startMotionPrio函数。相当于3.0的OnRenderObject自动调用TaskableModel.TryWriteParametersAndParts(Parameters, Parts); 效果完全和IK动画里面的绑定骨骼是一样的。这里编制动画，就和普通的编UI动画一样。 发布 这个插件在美术方面的玩法比较高级（编制各种动画效果），在程序方面需要写的代码基本没有，因为都封装好了。 如果想发布出来，是需要对贴图材质压缩一下的，能从原来的77+M，压缩到后面20+M的。操作不多，就是对贴图使用压缩、设置static等。能节省大半的资源，提倡使用的时候必须进行优化压缩。 实例程序中使用了鼠标跟踪、单击、重力传感器，来调用不同的动作（expressions文件夹中的4个，实际只有3个有有效动作）。可以自己修改，使用其他方式来调用。亦或直接找到全部键值，直接做动画。 体验demo ，请用Chrome或者手机浏览器打开。 改进 实际使用当然不是这么简单。这里举例，Lol英雄人物界面，是“底部的背景图”+中间能动的人物+“置顶的技能、血条等数值”。是三层结构的。 现在这个demo，直接拖图片进去，是不行的，那个会动的人物永远是置顶的。所以需要结合其他技术来处理。使用Layer吗？尝试了一下，没生效，相机不渲染该layer，人物还是在。找到dll里面设置layer的，直接提示无效，下载老版本的，提示该函数已过期。怎么办？ 只能去翻说明文档了，幸好找到了。 回头翻了一下实例工程！原来早就存在了这个功能的示例了。前面太心急，没仔细看示例工程才没发现。 新建摄像机，把liv2d拉成为它的子项，然后拖出去main摄像头视野外面。接下来就是弄RenderTexture了。 右键新建RenderTexture，按如下设置：其实可以弄成512x512的，再小下去就失真了（为什么是512？因为原图是1024x1024，512损失还没那么明显，256就大了）。 然后把RenderTexture拖给刚才建的摄像头。这里我选择取消全部layer渲染，culling mask设置为nothing，确保不会有其他东西进来这个摄像头的视觉。 新建panel，赋值刚才的材质。 运行，看到人物终于夹在中间了！ 但是这时候发现人物的眼睛跟踪鼠标，一直是看往左边的，因为实际的live2d在右边远处。这里就得去修改代码了。 这里的问题，就是坐标对应的是真实的Live2d。需要修改参照物为假的panel，或者直接把鼠标位置移过去。我选择了把鼠标点击计算值偏移过去的方案。]]></content>
      <categories>
        <category>第三方插件</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>Live2D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity异常处理---灯光渲染抛异常]]></title>
    <url>%2F29Unity_error_1%2F</url>
    <content type="text"><![CDATA[本文记录怎么处理“Unkown Mixed bake mode in LightModeUtil.MapSettings() UnityEditor.DockArea”异常。 当时是修改灯光渲染的时候抛的异常。没头绪，后来找到一篇文章 介绍这个。 老版本Unity上没这个问题，我是在2017上遇到的。]]></content>
      <categories>
        <category>异常处理</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单算法---求素数]]></title>
    <url>%2F28algorithm_2%2F</url>
    <content type="text"><![CDATA[本文以“判断101-200之间有多少个素数”介绍求素数的7种解法： 遍历每个值进行相除。 取开方根，只遍历2~开方根。 间隔6个数只取2个值计算，结合开方根。 从头开始，保存每个素数，遍历时只需要判断是否能让集合中的素数整除。 保存素数，结合开方根优化。 简单线性筛法。 优化版线性筛法。 该题较简单，但是没想到仔细想的时候发现解法这么多。 首先需要了解什么是素数：只能被1和本身整除的整数，就是素数。 最基础解法：遍历每个值相除 这是刚接触到题目时，每个人第一个想到的解法：用2~(该数-1)来除，如果都不能整除，这个数就是素数。 123456789101112131415161718192021222324252627/// &lt;summary&gt;/// 简单处理，一个一个数字去除/// &lt;/summary&gt;/// &lt;param name="beginnum"&gt;&lt;/param&gt;/// &lt;param name="endnum"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private int SimpleGetNum(int beginnum, int endnum)&#123; int i, j; int counts = 0; for (i = beginnum; i &lt;= endnum; i++) &#123; for (j = 2; j &lt; i; j++) &#123; //判断是否能整除 if (i % j == 0) break; &#125; //判断前面的循环是否会提前break，提前break时，j &lt; k ；有break说明能获得整除 if (j &gt;= i &amp;&amp; i != 0 &amp;&amp; i != 1) &#123; counts++; &#125; &#125; return counts;&#125; 但是，这里存在大量多余的判断。 遍历2~开方根 思想：一个数=前面某个数 X n ，推断出来，肯定存在“某个数” &lt; n，或者 n&lt; “某个数”。这样最极端的情况，就是n=这个“某个数”，得到数 = n2；所以我们只需要除前面这n个数，后面的操作都是重复的，就可以不除了。 123456789101112131415161718192021222324252627/// &lt;summary&gt;/// 结合算法思想处理，最多人使用的方式/// &lt;/summary&gt;/// &lt;param name="beginnum"&gt;&lt;/param&gt;/// &lt;param name="endnum"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private int NormalGetNum(int beginnum, int endnum)&#123; int i, j, k; int counts = 0; for (i = beginnum; i &lt;= endnum; i++) &#123; k = (int)Math.Sqrt(i); for (j = 2; j &lt;= k; j++) &#123; //判断是否能整除 if (i % j == 0) break; &#125; //判断前面的循环是否会提前break，提前break时，j &lt; k ；有break说明能获得整除 if (j &gt;= k &amp;&amp; i != 0 &amp;&amp; i != 1) &#123; counts++; &#125; &#125; return counts;&#125; 间隔6个数只取2个值计算 该解法是看到这个博客判断质数/素数——我知道的最快的方法 才想到的。通过观察，2、3包揽了几乎绝大部分的合数。 所有数可以大致以如下方式表示： … 6x, 6x+1, 6x+2, 6x+3, 6x+4, 6x+5, 6x+6 ==&gt; ==&gt; 6(x+1), 6(x+1)+1, 6(x+1)+2, 6(x+1)+3, 6(x+1)+4, 6(x+1)+5, 6(x+1)+6 … 其中6x, 6x+2, 6x+3, 6x+4都是合数，剩下 6x+1, 6x+5才存在素数的可能性。故实际，每6个数，只需要检查两个数！ 1234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt;/// 令x≥1，将大于等于5的自然数表示如下：/// ··· 6x，6x+1，6x+2，6x+3，6x+4，6x+5，6(x+1），6(x+1)+1 ···/// 故只需要判断6x+1和6x+5两个数，再间隔6个数再次判断/// &lt;/summary&gt;/// &lt;param name="beginnum"&gt;&lt;/param&gt;/// &lt;param name="endnum"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private int SuperNormalGetNum(int beginnum, int endnum)&#123; int i, j, k; int counts = 0; bool isnofrime = false; for (i = beginnum; i &lt;= endnum; i++) &#123; if (i % 6 != 1 &amp;&amp; i % 6 != 5) continue; isnofrime = false; k = (int)Math.Sqrt(i); for (j = 5; j &lt;= k; j += 6) &#123; //判断是否能整除 if (i % j == 0 || i % (j + 2) == 0) &#123; isnofrime = true; break; &#125; &#125; if (!isnofrime) &#123; counts++; &#125; &#125; return counts;&#125; 用前面存在的素数来遍历判断 合数能被素数整除，但是素数不能被其他素数整除。所以只需要保存前面获取的素数，后面的数直接除前面这些素数，不能整除，就也是素数！ 1234567891011121314151617181920212223242526272829303132333435363738/// &lt;summary&gt;/// 从2开始，获取素数，保存起来，给后面的数判断素数，一直判断到最大值。/// &lt;/summary&gt;/// &lt;param name="beginnum"&gt;&lt;/param&gt;/// &lt;param name="endnum"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private int ListGetNum(int beginnum, int endnum)&#123; int i, j, counts; List&lt;int&gt; primelts = new List&lt;int&gt;(); //加入第一个素数2 primelts.Add(2); for (i = 3; i &lt;= endnum; i++) &#123; for (j = 0; j &lt; primelts.Count; j++) &#123; //能整除，不是素数 if (i % primelts[j] == 0) &#123; break; &#125; else if (j == primelts.Count - 1) &#123; primelts.Add(i); break; &#125; &#125; &#125; counts = 0; for (i = 0; i &lt; primelts.Count; i++) &#123; if (primelts[i] &gt;= beginnum) &#123; counts++; &#125; &#125; return counts;&#125; 结合开方根用前面存在的素数来遍历判断 上面的方法同样存在重复判断，实际上当除以的素数大于开方根的时候，后面的素数就更加不可能了，该数直接可以断定是素数了。he = su1 x su2，当su1&lt; sqrt(he)时，su2 &gt; sqrt(he);当su1&gt;sqrt(he)时，su&lt; sqrt(he)，这里就重复了。所以当前面一段找不到结果，后面的肯定也找不到。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/// &lt;summary&gt;/// 从2开始，获取素数，保存起来，给后面的数判断素数，一直判断到最大值。/// &lt;/summary&gt;/// &lt;param name="beginnum"&gt;&lt;/param&gt;/// &lt;param name="endnum"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private int ListGetNum(int beginnum, int endnum)&#123; int i, j, counts, k; List&lt;int&gt; primelts = new List&lt;int&gt;(); //加入第一个素数2 primelts.Add(2); for (i = 3; i &lt;= endnum; i++) &#123; k = (int)Math.Sqrt(i) + 1; for (j = 0; j &lt; primelts.Count; j++) &#123; if (primelts[j] &gt; k) &#123; primelts.Add(i); break; &#125; //能整除，不是素数 if (i % primelts[j] == 0) &#123; break; &#125; else if (j == primelts.Count - 1) &#123; primelts.Add(i); break; &#125; &#125; &#125; counts = 0; for (i = 0; i &lt; primelts.Count; i++) &#123; if (primelts[i] &gt;= beginnum) &#123; counts++; &#125; &#125; return counts;&#125; 简单线性筛法 从头开始，剩下的最小的数肯定是素数，然后根据这个数，翻倍剔除掉剩下集合中的合数；最后转移该素数，继续轮回执行。执行到整个集合为空为止，全部素数已经转移出来。 1234567891011121314151617181920212223242526272829303132333435363738/// &lt;summary&gt;/// 简单线性筛法/// 从头开始，取到一个素数后，将后面对应该素数的合数全部删掉。/// 这样每一轮，剩下最小的那个数肯定是素数。/// &lt;/summary&gt;/// &lt;param name="beginnum"&gt;&lt;/param&gt;/// &lt;param name="endnum"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private int FilterNum(int beginnum, int endnum)&#123; Dictionary&lt;int, bool&gt; allnums = new Dictionary&lt;int, bool&gt;(); int mininum = 2; //按照顺序排放 for (int i = mininum; i &lt;= endnum; i++) &#123; allnums.Add(i, false); &#125; List&lt;int&gt; primelst = new List&lt;int&gt;(); while (allnums.Count &gt;= 1) &#123; mininum = allnums.ElementAt(0).Key; //第一个数是最小的，肯定是素数 allnums.Remove(mininum); primelst.Add(mininum); //int会溢出，需要设置为double才能防止溢出 for (int i = mininum; (double)i * mininum &lt;= endnum; i++) &#123; //将该素数对应的合数全部删除 allnums.Remove((int)(double)i * mininum); &#125; &#125; for (int i = 0; true; i++) &#123; if (primelst[0] &lt; beginnum) primelst.RemoveAt(0); else break; &#125; return primelst.Count;&#125; 这里可以用递归，但是数字大的时候会内存溢出。所以我取消了递归的方式。同时还得注意int溢出的问题，会出现46957*91467==48623为true的现象。因为int有最大值，超过就会循环取值了，正转负，负转正。 优化版线性筛法 上面的解法同样存在重复操作。理想情况，一个数只用剔除一次。 该解法是看到这个文章线性筛法求素数的原理与实现 才想到的。 这里讲解一下： 合数 = A x B，当A/B又是合数时，重复下去，合数 = …x…x素数 ==&gt; 最大素数 x 第二大素数 x … x 最小素数 所以只要我们找到最小素数，把它当做B，而A又唯一（递增的i），该合数就唯一确定了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// &lt;summary&gt;/// 改进FilterNum存在重复操作的缺点/// &lt;/summary&gt;/// &lt;param name="beginnum"&gt;&lt;/param&gt;/// &lt;param name="endnum"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private int SuperFilterNum(int beginnum, int endnum)&#123; Dictionary&lt;int, bool&gt; allnums = new Dictionary&lt;int, bool&gt;(); List&lt;int&gt; primelst = new List&lt;int&gt;(); //先将所有数设为素数 for (int i = 0; i &lt;= endnum; i++) &#123; allnums[i] = false; &#125; for (int i = 2; i &lt;= endnum; i++) &#123; if (!allnums[i]) &#123; //false为素数 primelst.Add(i); &#125; // j =0 ==&gt; primelst[0] ==&gt; 2 * i &lt;= endnum 过滤掉后面一半的数, 因为 合数 = A x B ，必定存在 A(或者B) &lt;= 二分之一 ， // 所以实际排查前面二分之一的值时 , 后面二分之一的也已经把合数去掉了 for (int j = 0; j &lt; primelst.Count &amp;&amp; primelst[j] * i &lt;= endnum; j++) &#123; // 用已获得的素数 x index , 排查出对应唯一确定的合数 allnums[primelst[j] * i] = true; // 重点！通过查找最小素数，防止了重复操作 // 合数 = A x B，当A/B又是合数时，重复下去，合数 = ...x...x素数 ==&gt; 最大素数 x 第二大素数 x ... x 最小素数 // i % primelst[j] 就break，说明已经找到最小素数（j从0开始++） // 此时break，合数 = i x 最小素数primelst[j] ，能唯一定位到该合数。不会存在重复定位该合数 // 举例：合数12 (有两种定位方式)== 4 x 3 ==&gt; 2 x 2 x3 // == 6 x 2 =&gt; 3 x 2 x 2 // 实际i=4的时候，定位的是8=4x2就break；不会去定位12=4x3 // i=6的时候，才定位12； // //同理，合数18 == 6x3 ==&gt; 2x3x3 // == 9x2 ==&gt; 3x3x2 //i=6，定位12就break；等到i=9才来定位18 if (i % primelst[j] == 0) break; &#125; &#125; while (primelst[0] &lt; beginnum) &#123; primelst.RemoveAt(0); &#125; return primelst.Count;&#125; 结尾得提一下，上面的算法，三个优化版本，在数据量不大的情况下（十万左右），线性筛选法优势不大，间隔6的那种最快；但是当达到百万以上，线性是最快的！ 每次运行的时间都会有一点点的区别。注意是毫秒，千分之一秒。所以上面的数据出来是超级快的。 git代码库: Codes]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http接口调试---天气API获取]]></title>
    <url>%2F27getweatherapi%2F</url>
    <content type="text"><![CDATA[本文通过天气API的获取，记录分享http接口该怎么看文档，怎么调试使用。 数据来源国内接口中国天气网 当然还有其他超级多的接口。具体这里有篇文章也在介绍总结：免费、稳定的天气预报API 这里还得记录一下接口中的地区编号怎么查询。幸好git上有人整理分享了这个：地区编码整理 国外接口openweathermap 同样得有一个查询地区编号的地方，这个在示例里面有：地区编码查询 。下载下来后，解压用文本格式打开，Ctrl F就能找到想要的地区的编号： http接口调试工具—Fiddler 有了接口规范和调试地址，现在就可以开始调试了。下面以Fiddler的调试为例，简单记录怎么看文档，怎么使用该工具获取到数据。 获取key api接口使用，大部分是需要先注册账号，购买（有免费的，但是得点击“购买”，以获取key）。绝大部分都会要求key，有的key是附带在get模式下，附带在http连接最后面；有的是post模式下，作为一个key附加。 这个key的作用，就是标记跟踪使用。服务端保存一个key，用户端必须也有对应的key，才给权限操作。 类似使用场景有：用户登录后的定时权限检验（每次登录会刷新key，在这段时间内操作，必须有这个key才有权限操作，通常30s服务端该key会变化，防止用户穿过登录来直接操作），这里为什么不用用户名+密码？因为密码必须要加密，这样每个接口都要进行密码的解密验证，性能消耗大；而用加密后的字符串直接比对的话，存在一种情况，当用户登录后，该连接信息被窃取（网络截获），这样就可以直接跳过登录，使用该字符串当key直接超权限操作了；同时下线长时间离线无操作客户端的功能，也是用到该key，长时间离线下，应该无权限操作，因为key和服务端上的不匹配，必须登录获取最新key才能操作。 下面直接使用国外那个接口的来记录： 注册登录后（这里可能需要VPN），可以去申请自己的key。这里使用默认分配的key来演示。 记录保存该key。然后点击API导航。 看文档 这里我选中Current weather data来记录： 文档已经提示了接口格式，但是发现直接这样使用是报错的，提示的401。401错误就是提示未登录，想想前面提到了key，但是这里怎么就没使用？ 打开一下示例的链接（Example）： 发现是需要附带&amp;appid= XXXXX。 这种就是get模式下key的附带方式，放在最后，前提是需要找到这个key对应的“appid”这个字符串是叫什么，不同接口使用的字符串不同。 使用工具预调试 下面就使用Fiddler来记录，做网页的朋友应该用的较多是postman。 该工具作用很大，能捕捉电脑上的全部http通讯。也能作为http调试工具使用。 这里简单介绍作为调试工具使用的记录： 上面分析得到的http链接，其实在空网页上打开已经能获取到data了，但是一般情况会乱码；而且，如果是post模式，就不会直接显示在网页上，找起来很麻烦，所以一般都是直接用调试工具。使用工具，主要原因也是因为这些接口不单单是一个http字符串来的，还是附带好多其他设置项： 这里使用广东省，查上面文档，中间是有空格的，需要转码。 首先需要知道是get还是post，然后就是HTTP规范1.1。get模式直接复制http串进去就行了，直接回车或者Execute。就可以看到左边的“Result为200”的串，双击就能看到结果了。而post模式下，就需要把附加key全部复制进去下面那个框。 调试工具已经识别出来返回的是json，自动帮我们解析了，当然也可以看原文本，选择“TextView”。旁边那些Headers等等也有蛮多有用信息可以看的，如果出错的话，就需要关注这些信息了。 http接口，一般要注意编码，还有http串里面一些特殊字符串，http在开发中使用超级多。这里只是简单提及。Fiddler的功能实际也是超级多的，有兴趣的可以多多摸索，该工具免费，同时该工具的同家族中也有个免费的反编译工具，也有收费的界面工具（实际某度可以搜到老版本的破解），做界面的朋友可以关注一下。做客户端的朋友们，可能有人会发现Win10更新到某版本后，IE内核那个dll变化比较大，导致自定义浏览器的一些网页会出问题，Fiddler解决了该问题，目前还没找到Fiddler怎么处理的，只知道打开Fiddler捕捉时，那些网页就正常，关掉后就恢复原来的异常状态了。老外在做浏览器这方面还是很牛逼的，不得不佩服。 结尾附加一下中国天气网的api查询接口示例，不用key： 后面我再另外设文章分享怎么用C#写http接口服务端，Restful的普通json模式，以及table提交模式。当然还有使用xml格式的soap。]]></content>
      <categories>
        <category>联调</category>
      </categories>
      <tags>
        <tag>接口调试</tag>
        <tag>API使用</tag>
        <tag>http调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity优化_WebGL发布优化]]></title>
    <url>%2F26UnitySuper_1%2F</url>
    <content type="text"><![CDATA[本文是记录Unity的优化第一篇：WebGL发布优化。 后续将记录其他平台的优化，以及编程中遇到的优化。 开头分享几个博客链接： 来自印度的：App Guruz Unity社区的两篇文章： 了解Unity WebGL中的内存 Unity WebGL内存：Unity Heap 本文就不重复博文中的细节了。 Unity发布WebGL版本，限制是很大的，必须事先定义所需内存，一旦决定，就不能减少或者增加！而且包不能太大，下载速度严重影响启动时间。特别是还有部分API限制。总体上，限制因素很多。当然，如果用2018新特性的，就能动态内存及高压缩。不过，目前还是先从普通版本做起。 小游戏是可以发布成WebGL版本的，但是大游戏难度系数很高，特别是画面越精美的。因为要考虑web可以运行在任何低配置的场景，特别是跑在手机32位浏览器。 针对Unity发布WebGL，细节有好多，目前我就按照遇到的问题，从初级开始，一个一个分享记录吧。 本博客会不定时分享部分官方商店里面的小游戏，同时发布成WebGL版本让大家可以体验。 先记录简单发布2D拾荒者遇到的问题吧。 疑难解答360打不开 该问题在前面的博客有提到，是新版本的Unity编译的包，部分浏览器暂时不支持WebGL2.0的特性，所以识别不了，就不能打开了。 只要用老版本的Unity编译发布，就可以使用了。目前我用的是5.4.6f3。发布出来是Release包；再往上的版本发布的是Build包，就得用Chrome和手机浏览器打开了。 抛异常–内存不足 这个需要细谈。是本篇的重点。 Unity发布的这个webgl，运行在浏览器上，是需要事先定义内存的，后面不能减小或者增大。所以得了解你这个程序最少需要多少内存，然后根据2的幂来取值。 那怎么看程序需要多少内存？ Profiler 在memory部分，可以查看当前场景使用了多少内存。一般看Texture和Audio就行，这两个是最大的，加起来的值就是至少需要的内存，往上取2的幂就能大概出一个值了。像图中，大致23m，所以往上取32m就行。 gzip解压方式 这里还有个办法，就是先编译一次包。然后把Release里的3个包全换成后缀gzip，解压出来，凑起来的大小就是到时在浏览器里的大小。 优化（重点）删除多余文件 第一个，首要的，删除多余文件。 可以通过%homepath%\AppData\Local\Unity\Editor\Editor.log，或者是在Console窗口最右边打开。 查看该日志，可以看到里面记录了整个编译过程，包里有什么文件，大小等等信息。 图片压缩 图片压缩在5.x版本的优化选项较少，在2018的就多了，可以选择压缩类型、压缩质量等等参数。 5.x的取消Generate Mip Maps ， 因为只是普通的2D图片，不需要3D效果。 然后就是根据自己喜好来调压缩比例了。压缩质量越低，看起来越模糊。 audio压缩 其实也不算压缩，只是修改了音频文件的读取方式而已。 首先要找出大文件，一般是背景音乐： 这里可以修改的只有一个Load Type选项，一般情况下忽略第一个。第二第三差不多，一般都是建议大文件选第二个（Compressed in memory）；零碎的小文件选第三个（streaming）。区别就是加载时会不会存在延迟，这个在大文件上才会体现出来。 记住这里选第一个的话，这12个文件，会导致运行时的audio内存高达13m。选stream的话才250kb。差别很大的。 其他优化 在这个2D小游戏中，剩下其他的优化效果很小，就设置static选项（让系统自动优化）、取消天空盒等等细节。所以暂时不提，等后面3D部分的再说这个优化。 编译优化 由于这个2D小游戏很简单，没涉及其他的，所以可以直接上编译选项优化了。 直接到Player Settings设置： Enable Exceptions设为None，启用Data caching。根据前面观察的内存大小，设置一个值（该值后面能在文本文件直接修改，故此处影响小，随便填）。 这里只有两个是必须的： 启用“Strip Engine Code”，该项表示剔除不用的dll。 不打印log。 其他的看喜好选吧。不是必要设置。然后就可以编译出包了！ html优化 现在可以运行看到效果了，初始是不提供file模式看效果的，这里有篇文件介绍怎么设置Chrome支持file模式运行： Unity发布WebGl注意事项 细节我就不再提了。下面要说的是怎么让内容居中显示： 初始启动，是在左上角的。体验不是很好。但是可以用F12看到，是绘制在canvas上的内容，是可以通过修改html代码来实现居中显示的。 html居中显示的方式是： 增加div。 设置style=”position: absolute;left:50%;top:50%;margin-left:0px;margin-top:0px;” 注意这里有个margin偏移值，因为目前的居中设置，是以该内容的左上角来居中的，所以出来效果是在第四象限的位置。就得让它根据自己的大小来偏1/2过去，就居中了。 由于html代码不支持动态计算，所以只能写css脚本了： 123456789 &lt;div id="contdivc" style="position: absolute;left:50%;top:50%;margin-left:0px;margin-top:0px;"&gt; &lt;script type='text/javascript'&gt; window.onload=function() &#123; document.getElementById( "contdivc" ).style.marginLeft = "-"+960/2 + "px"; document.getElementById( "contdivc" ).style.marginTop = "-"+600/2 + "px"; &#125; &lt;/script&gt; &lt;canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" height="600px" width="960px"&gt;&lt;/canvas&gt;&lt;/div&gt; 现在刷新运行，居中了！ 但是不能每次编译都来这里修改html的呀。怎么处理？ 回到开头，Unity日志里面其实有提到，是用插件来编译的，这样，是肯定存在一个模版文件的！ 该模版就在安装目录下：5.4.6f3\Editor\Data\PlaybackEngines\WebGLSupport\BuildTools\WebGLTemplates 那就好办了，直接改该文件就行了： 123456789 &lt;div id="contdivc" style="position: absolute;left:50%;top:50%;margin-left:0px;margin-top:0px;"&gt; &lt;script type='text/javascript'&gt; window.onload=function() &#123; document.getElementById( "contdivc" ).style.marginLeft = "-"+%UNITY_WIDTH%/2 + "px"; document.getElementById( "contdivc" ).style.marginTop = "-"+%UNITY_HEIGHT%/2 + "px"; &#125; &lt;/script&gt; &lt;canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" height="%UNITY_HEIGHT%px" width="%UNITY_WIDTH%px"&gt;&lt;/canvas&gt;&lt;/div&gt; 文末贴几个我觉得还不错的文章： Unity发布WebGl注意事项 Unity 性能优化（力荐） unity几种优化建议 Unity5.3.3 webgl 注意 [Unity优化]减少内存占用：贴图优化 Unity3d Mesh、Texture、UI 压缩降低内存 Unity游戏开发性能优化（Sprite优化） Unity游戏开发图片纹理压缩方案]]></content>
      <categories>
        <category>Unity优化</category>
      </categories>
      <tags>
        <tag>发布优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity平台预编译指令]]></title>
    <url>%2F25UnityPlatform_define%2F</url>
    <content type="text"><![CDATA[本文记录Unity的平台预编译指令。 官方文档 在脚本中，经常看到define指令，具体到底有多少指令？下面简单转载一下官方文档。 table th:first-of-type { width: 200px; } 定义 作用 UNITY_EDITOR #define指令，用于从游戏代码中调用Unity Editor脚本。 UNITY_EDITOR_WIN Windows上编辑器代码的#define指令。 UNITY_EDITOR_OSX Mac OS X上编辑器代码的#define指令。 UNITY_STANDALONE_OSX #define指令，用于编译/执行专门用于Mac OS X的代码（包括Universal，PPC和Intel架构）。 UNITY_STANDALONE_WIN #define指令，用于专门为Windows独立应用程序编译/执行代码。 UNITY_STANDALONE_LINUX #define指令，用于专门为Linux独立应用程序编译/执行代码。 UNITY_STANDALONE #define指令，用于编译/执行任何独立平台（Mac OS X，Windows或Linux）的代码。 UNITY_WII #define指令，用于编译/执行Wii控制台的代码。 UNITY_IOS #define指令，用于编译/执行iOS平台的代码。 UNITY_IPHONE 已过时。请改用UNITY_IOS。 UNITY_ANDROID 适用于Android平台的#define指令。 UNITY_PS4 用于运行PlayStation 4代码的#define指令。 UNITY_XBOXONE 执行Xbox One #define指令代码。 UNITY_TIZEN Tizen平台的#define指令。 UNITY_TVOS Apple TV平台的#define指令。 UNITY_WSA 通用Windows平台 #define指令。此外，NETFX_CORE是在针对.NET Core编译C＃文件和使用.NET 脚本后端时定义的。 UNITY_WSA_10_0 通用Windows平台的#define指令。另外，在针对.NET Core编译C＃文件时定义了WINDOWS_UWP。 UNITY_WINRT 与UNITY_WSA相同。 UNITY_WINRT_10_0 相当于UNITY_WSA_10_0 UNITY_WEBGL WebGL #define指令。 UNITY_FACEBOOK Facebook平台的#define指令（WebGL或Windows独立版）。 UNITY_ADS #define指令，用于从您的游戏代码中调用Unity Ads方法。5.2及更高版本。 UNITY_ANALYTICS 用于调用Unity Analytics的 #define指令为游戏代码方法。5.2及更高版本。 UNITY_ASSERTIONS 断言控制进程的#define指令。 这里插入一下MarkDown插入表格的技巧：Markdown 表格之调整宽度技巧 还有给定版本号XYZ Unity以下列格式公开三个全局#define指令：UNITY_X，UNITY_X_Y和UNITY_X_Y_Z 例如：Unity 5.0.1指令的示例： 定义 作用 UNITY_5 每个5.XY版本都公开了Unity 5发行版的#define指令。 UNITY_5_0 主要版本Unity 5.0的#define指令，在每个5.0.Z版本中公开。 UNITY_5_0_1 Unity 5.0.1次要版本的#define指令。 还能以UNITY_X_Y_OR_NEWER格式来有选择地编译代码。 定义 作用 ENABLE_MONO 为Mono编写后端#define脚本。 ENABLE_IL2CPP 用于IL2CPP的脚本后端#define 。 ENABLE_DOTNET 脚本编写后端#define for .NET。 NETFX_CORE 在.NET上针对.NET Core类库构建脚本时定义。 NET_2_0 在Mono和IL2CPP上针对.NET 2.0 API兼容级别构建脚本时定义。 NET_2_0_SUBSET 在Mono和IL2CPP上针对.NET 2.0 Subset API兼容级别构建脚本时定义。 NET_4_6 在Mono和IL2CPP上针对.NET 4.x API兼容级别构建脚本时定义。 NET_STANDARD_2_0 在Mono和IL2CPP上针对.NET Standard 2.0 API兼容级别构建脚本时定义。 ENABLE_WINMD_SUPPORT 在IL2CPP和.NET上启用Windows运行时支持时定义。有关详细信息，请参阅Windows运行时支持 。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5个简单算法]]></title>
    <url>%2F24algorithm_1%2F</url>
    <content type="text"><![CDATA[本文介绍五个算法小题目： 四个不同数字组成互不相等且不重复的三位数。 斐波那契数列。 字符串转整型。 简单逻辑思考题。 数组移动 分享一下博客上看到的一些算法题： 四个数字组成三位数 有数字：1、2、3、4，请问能组成多少个互不相同且无重复数字的三位数？请输出这些数字。 解法 三位数，百位数有4种选择，则十位数有3种选择，从而个位数只有2种选择。共4x3x2=24种情况。 123456789101112131415int count = 0;for (int i = 1; i &lt;= 4; i++)&#123; for (int j = 1; j &lt;= 4; j++) &#123; if (i == j) continue; for (int k = 1; k &lt;= 4; k++) &#123; if (j == k || k == i) continue; count++; Console.WriteLine("第&#123;1&#125;种情况：&#123;0&#125;", i * 100 + j * 10 + k, count.ToString("00")); &#125; &#125;&#125; 如果要写能处理不同输入数字数量的，就得用递归： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/// &lt;summary&gt;/// 题目：有数字：1、2、3、4，请问能组成多少个互不相同且无重复数字的三位数？请输出这些数字。/// &lt;/summary&gt;public class NumToInt : IGetResult&#123; public void ConsoleOut() &#123; List&lt;int&gt; inputlst = new List&lt;int&gt;() &#123; 1, 2, 3, 4 &#125;; int[] inputnums = inputlst.ToArray(); List&lt;int&gt; result = NumToIntMethod(inputnums); StringBuilder txt = new StringBuilder(); if (result.Count &gt; 0) &#123; txt.Append("结果共 " + result.Count + " 个；分别是： "); for (int i = 0; i &lt; result.Count; i++) &#123; if (i &lt; result.Count - 1) txt.Append(result[i] + "、 "); else txt.Append(result[i]); &#125; &#125; else &#123; txt.Append("存在重复数字，请重新输入！"); &#125; Console.WriteLine(txt.ToString()); &#125; /// &lt;summary&gt; /// 输入有多少数字，组合排序后输出结果 /// &lt;/summary&gt; /// &lt;param name="inputnum"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private List&lt;int&gt; NumToIntMethod(int[] inputnum) &#123; List&lt;int&gt; results = new List&lt;int&gt;(); //去除重复值 int[] hassamenum = inputnum.GroupBy(i =&gt; i).Select(i =&gt; i.Key).ToArray(); //不存在重复值 if (hassamenum.Count() == inputnum.Count()) &#123; GetNum(0, inputnum.ToList(),ref results); &#125; return results; &#125; /// &lt;summary&gt; /// 递归调用 /// &lt;/summary&gt; /// &lt;param name="beforenum"&gt;前面组合的数字&lt;/param&gt; /// &lt;param name="leftlst"&gt;剔除掉已选数字后的集合&lt;/param&gt; /// &lt;param name="alllst"&gt;全部结果总集合&lt;/param&gt; private void GetNum(int beforenum, List&lt;int&gt; leftlst, ref List&lt;int&gt; alllst) &#123; //只剩最后一个数字，表示可以输出结果 if (leftlst.Count == 1) &#123; if (!alllst.Contains(beforenum))//检查是否重复，99.9%概率不会重复 &#123; alllst.Add(beforenum); &#125; else &#123; Console.WriteLine("重复！"); &#125; return; &#125; for (int i = 0; i &lt; leftlst.Count; i++) &#123; //将前面的数字组合 int tmpnum = beforenum * 10 + leftlst[i]; List&lt;int&gt; tmplst = new List&lt;int&gt;(); tmplst.AddRange(leftlst); //剔除已组合的数字 tmplst.RemoveAt(i); GetNum(tmpnum, tmplst, ref alllst); &#125; &#125;&#125; 斐波那契数列 有一列数：1、1、2、3、5……求第30个数。 解法 第i个数等于第(i-1)个数+第(i-2)个数。使用递归。 1234567private int GetNum(int index)&#123; if (index &lt;= 0) return 0; else if (index &lt;= 2) return 1; else return (GetNum(index - 1) + GetNum(index - 2));&#125; 这里提一下我们在朋友圈经常看到的一个斐波那契数列应用：切割巧克力 某人把一个8x8的巧克力切成4块，却能拼成一个5x13的长方形==》64 = 65?! 其实这里就是利用了斐波那契数列的这个性质：5、8、13正是数列中相邻的三个项！每个奇数项的平方都比前后两项之积多1，每个偶数项的平方都比前后两项之积少1。加上另一个特性：前一项与后一项之比越来越接近黄金分割。 字符串转整型 将用户输入的字符串，不用系统api转化为整型。 解法 依靠ASCII，或者每个char与0的差值，判断是否为数字，是否10之内。 123456789101112private int GetNum(string str)&#123; int num = 0; int gap = 0; for (int i = 0; i &lt; str.Length; i++) &#123; gap = str[i] - '0'; if (gap &lt; 0 || gap &gt;= 10) return -1; num = num * 10 + gap; &#125; return num;&#125; 逻辑思考题 A、B、C、D、E五个学生计划报名参加活动，请根据以下条件判断谁真正参加活动： A参加，B也参加； B和C只有一个人参加； C和D或者都参加，或者都不参加； D和E中至少有一个人参加； 如果E参加，那么A和D也参加。 解法 1，0为参加或者不参加；设置5个循环进行判断，将条件转化成对应的值判断进行循环。 1234567891011121314151617181920212223242526272829303132char[] name = &#123; 'A', 'B', 'C', 'D', 'E' &#125;;int[] value = new int[5];for (value[0] = 0; value[0] &lt; 2; value[0]++) // &lt; 2 取0、1两个值&#123; for (value[1] = 0; value[1] &lt; 2; value[1]++) &#123; for (value[2] = 0; value[2] &lt; 2; value[2]++) &#123; for (value[3] = 0; value[3] &lt; 2; value[3]++) &#123; for (value[4] = 0; value[4] &lt; 2; value[4]++) &#123; if((value[1]&gt;=value[0]) //B不参加时，A肯定不参加；B参加时，A不一定参加 &amp;&amp;(value[1]+value[2]==1) &amp;&amp;(value[2]==value[3]) &amp;&amp;(value[3]+value[4] ==1) &amp;&amp;(value[4]==0 ||(value[4] == 1&amp;&amp;value[0] ==1 &amp;&amp; value[3] ==1))) &#123; for (int i = 0; i &lt; value.Length; i++) &#123; if (value[i] == 1) Console.WriteLine("&#123;0&#125;参加",name[i]); else Console.WriteLine("&#123;0&#125;不参加", name[i]); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 该逻辑思考题比较有趣，第一次看到这样和代码结合起来的逻辑题。 数组移动 这个得推荐去链接中的博客 仔细看，想法很新奇的。 这里简单拿一个来讲： 把数组元素前后部分交换 MoveFirstPartOfArrayToTheEnd(int[] array, int index) 比如 {1,2,3,4,5,6,7} 3 =&gt; {4,5,6,7,1,2,3} 解法 简单处理：把1-2-3排后面；然后从头开始把剩下的排进去。 123456789101112131415161718192021private void GetNum()&#123; int index = 3; int[] aa = new int[7] &#123; 1, 2, 3, 4, 5, 6, 7 &#125;; int[] bb = new int[aa.Count()]; for (int i = 0; i &lt; aa.Count(); i++) &#123; if (i &lt; index) &#123; bb[i + (aa.Count() - index)] = aa[i]; &#125; else &#123; bb[i - index] = aa[i]; &#125; &#125; foreach (var item in bb) &#123; Console.WriteLine(item); &#125;&#125; 上面的处理思想一般般，该题主要是了解链接中反转的用法： 分段1，2，3—4，5，6，7 分段反转3，2，1 — 7，6，5，4 整体反转4，5，6，7，1，2，3 12345678910111213141516171819202122232425262728293031323334private void ReverseNums()&#123; int[] aa = new int[7] &#123; 1, 2, 3, 4, 5, 6, 7 &#125;; int[] a1 = new int[3]; for (int i = 0; i &lt; a1.Count(); i++) &#123; a1[i] = aa[i]; &#125; int[] a2 = new int[7 - 3]; for (int i = 0; i &lt; a2.Count(); i++) &#123; a2[i] = aa[i + a1.Count()]; &#125; var b1 = a1.Reverse().ToArray(); var b2 = a2.Reverse().ToArray(); for (int i = 0; i &lt; a1.Count(); i++) &#123; aa[i] = b1[i]; &#125; for (int i = 0; i &lt; a2.Count(); i++) &#123; aa[i + a1.Count()] = b2[i]; &#125; var bb = aa.Reverse().ToArray(); foreach (var item in bb) &#123; Console.WriteLine(item); &#125;&#125; git代码库: Codes]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity发布WebGL---360等部分浏览器不支持]]></title>
    <url>%2F23unitywebgl360error%2F</url>
    <content type="text"><![CDATA[本文介绍三种版本Unity发布WebGL对浏览器的影响问题： 2018.2全新支持WebAssembly，支持内存动态调配，极大压缩包大小。 5.5.0能发布Release版本，但是在360等浏览器上会抛异常；再往上的版本只能发布Build版本。 5.4.6以下版本，发布Release版本，支持360等浏览器运行。 准备在博客上发一个小游戏demo，结果在360抛异常了，在chrome上是可以的，手机上也行。所以webgl是没问题的，推测是unity编译器的问题。但是搜索上找不到关键字。可能没什么人关注这个问题吧，毕竟都是用在手游上的。 通过浏览器调试工具，排查到是缺少“decompress.js”，比较了一下，编译出来”.unityweb”后缀的，都是没有“UnityConfig”文件夹。由于不同版本生成的UnityLoader.js不同，调用工具的步骤已经不同了，才导致360等低版本的浏览器打不开新Unity特性的WebGL程序。 由于C++方面和编译器有关，好多用2008可以编译，但是2010开始的会抛异常。所以就尝试用5.x的来编译。结果很神奇，出来的包不一样，是Release文件夹！之前用2017是Build文件夹。没想到360竟然这次跑成功了！ 由此推断是webgl版本问题。接着是一个一个版本的更新看，5.5的更新还有提到gz，后面的没提到，下载了5.6的，编译出来是build；所以再找5.5的，终于是Release，但是360上抛异常了。那往前一个版本，5.4.6，正常运行！ 下面是3个版本的运行情况： 2018.2.13f1-WebAssembly模式 由于WebAssembly的比较亮点：包小很多，而且能动态申请内存，可以一开始就申请32m（其他版本的都得申请64m）。这里就选该模式。 2017.4.3f1 WebAssembly模式在该版本是测试版，编译出来的包太大，而且运行还抛异常，这里就不提这个。 5.4.6f3 能编译出来360正常运行的版本中最新的一个。 结论 通过前面三个版本的比较。推荐： 简单的小游戏用5.4.6发布，请求量少，支持的浏览器多； 复杂的游戏用2018.2发布，包压缩率高，动态内存，但是手机上打开会提示请求摄像头权限？（可能存在扫描设备的代码） 中间的版本优势不大。通过Profiler工具的比较，2018的优势&gt;&gt;5.4.6 两个的代码和设置是一样的，但是Textures相差一倍，Textures是优化中最重要的一个，2018的竟然能帮我们直接优化了一倍。还有Assets的数量，也是一倍的差距。 再加上OpenGL ES3.0的优势，所以，复杂点的游戏，还是推荐用2018.2！ 文末贴一下介绍2018.2的WebAssembly的一个中文链接： Unity 2018.2正式支持WebAssembly]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>webgl</tag>
        <tag>环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity入门官方案例---2D Roguelike]]></title>
    <url>%2F22Roguelike%2F</url>
    <content type="text"><![CDATA[介绍一下接触到的好的Unity官方作品：2D Roguelike 。 游戏简介 该小游戏是2D类型，操作只有上下左右4个方向的移动，每动一下消耗1点能量，能量通过吃到食物补充；场景中有墙阻挡，需要撞4下墙才能销毁该障碍，同时还有怪物追击，被攻击到会大量消耗能量；但是怪物移动速度缓慢。 由于场景中的食物是固定的，吃了就没了，所以就设置了一个刷新点：“exit出口”，每到达一次，就能刷新一下全图场景，同时作为天数记录+1天；相应的，存活天数越多，怪物也会越多！ 目前游戏以天数为关卡记录。 游戏体验 游戏制作 原材料真的很少，才一张图集。里面打包集合了全部墙和地板、人物的贴图。然后就是一些背景音乐了。 1.游戏规则细化 写代码前，需要先了解要做什么功能。 这是一个逃亡游戏，为了限制逃亡，需要加上“移动能量消耗”这个限制；竟然是逃亡，那就有怪物，先用最简单的，降低怪物移动速度（玩家移动两次，怪物才移动一次），怪物接触玩家，玩家损失能量；接下来，场景中需要有障碍物，但是这些障碍物是可以通过消耗能量来击穿，防止堵死。 剩下就是全游戏最重要的能量了，设置两种食物，拾取到就增加能量。能量归零，游戏结束。 为了简化游戏，把全部对象设置了统一单位移动。全部材料统一单位。全场景10x10单位，减掉外围的一层墙，内部是8x8单位的地板，随机布置障碍物、食物和怪物。 增加存活天数为关卡难度设置，天数越多，难度越大；难度以怪物数量来体现。 2.代码 这个代码架构很不错。使用抽象层，由于怪物和玩家都是一样的移动，一样的碰撞，该部分能通过泛型T抽象出来处理。而碰撞，玩家的碰撞和怪物的碰撞又是一样的逻辑，又可以抽象处理。 细节的代码逻辑这里就不提了。这里简单讲讲里面一些知识点吧。 RuntimeInitializeOnLoadMethod 该特性，实际是让函数在物体在OnLoad的时候自己执行该函数。这里有篇文章Unity的RuntimeInitializeOnLoadMethod属性初探 简单讲。 Input.GetAxisRaw Raw不经过处理的，会直接返回-1，0，1。 Input.GetAxis则是-1~+1的范围缓慢变化。两者有区别。由于我们限制了单位移动，所以用raw的才适合。 float.Epsilon 这里使用StartCoroutine来处理，防止while卡死线程。注意StartCoroutine和多线程不是同样的概念。但是可以简单理解成另外开一个线程去处理这个一帧一帧移动的动画。判断是否移动到目的的时候，不是用==，而是用float.Epsilon，避免了一些数据溢出的bug。注意,实际上会出现 double 1.0!= 1.0，所以只能会一个很小的范围来判断是否 double 1.0 ≈ 1.0。 Physics2D.Linecast 游戏中使用的是碰撞器，所以移动前可以事先检查目的单位是否存在碰撞器。但是需要注意，物体自身的碰撞器会先被射线检测到，所以需要提前屏蔽自身的碰撞器，检测后才启用。 输入检测 这里我修改了原来的代码。原来是通过平台处理，移动端使用滑动手势。我觉得不好用，还是统一成单点判断处理。通过判断点击的部位在人物的相对位置来处理。 鼠标点击转化为相对坐标 touchEnd = Camera.main.ScreenToWorldPoint(Input.mousePosition); 这里，其实整个游戏的坐标，是通过相机上的单位来换算统一成单位坐标的。所以可以直接使用相机的相对坐标来处理。 代码小缺陷处理 我发现，当你剩下最后1能量，刚好移动到Exit就为0时，是能加载到下一关，然后就全部不动了。因为这里缺少了判断。 由于我使用了游戏结束后重新开始，我改的是下面这里。 3.开始制作游戏 这里比较简单，把图集拆开，制作预制体。两个步骤而已。 拆图集 拆图集，这里需要了解一个概念：Pixels Per Unit 这里我为什么设置成32？ 首先，我们看原文件大小： 是指位深度？不是这样算。我们数一下图集里面的单元，共7 x 8 。 对应：256==》8 &amp; 224 ==》 7 刚好整除，得到32像素就是一个图片的单位，也刚好图片都是正方形大小。所以这里的Pixels Per Unit，就是指多少像素一个Unit。 这里也有个文章介绍这个 Unity UGUI 原理篇(二)：Canvas Scaler 縮放核心 其他优化部分就不记录。因为有另外分开文章记录发布优化。 制作预制体 该部分简单，就是拖拖图片而已。注意里面碰撞器是和图片岔开的，偏移一半。 为什么要岔开，因为初始状态下，射线检测的出发点，是在左上角。这样一开始就碰到左边的物体了。所以需要岔开。增加一半单位的距离。 整合Scene 这里有疑问的，就是这个Size的值，应该设多少？ 这个Size的意义，是显示界面高度的一半，共多少个单位。这里5，得到显示界面的高度是10个单位，正好对应游戏中10x10的比例。 为什么不是宽度？这个就得去问官方了。本问不纠结这个问题。 为什么开头演示那里是正方形的大小，但是默认工程是长方形的？ 这个是发布时的设置。 当然，该游戏实际上不用碰撞器也行，因为单位长度都是1，实际可以用数组集合来记录处理。有点像扫雷游戏那样。具体后面分享到扫雷游戏再提这种写法。]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>2D</tag>
        <tag>入门级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[abowman's demo]]></title>
    <url>%2F21swfobjectdemo%2F</url>
    <content type="text"><![CDATA[本文分享swfobject 插件的简单使用，展示abowman上面的3个小挂饰。 swfobject的git代码里面已经包了一个自动生成html的功能，所以实际是去找swf动画，加进去就可以看到效果了。 小鱼挂饰： Download fish.swf 宠物鼠挂饰： Download hamster.swf 企鹅群挂饰： Download penguins.swf]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>abowman</tag>
        <tag>swf</tag>
        <tag>flash</tag>
        <tag>swfobject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度sitemap和谷歌sitemap同时使用不同的url]]></title>
    <url>%2F20sitemap2url%2F</url>
    <content type="text"><![CDATA[本文分享如果在同一次hexo g中，百度sitemap和谷歌sitemap使用不同的url。 目前我挂谷歌是挂github的链接，而挂百度使用域名。但是默认配置文件中的url只有一个。这样每次生成，他们都会使用那个默认url。这样得生成两次，分开提交才能做好。 真有必要这么麻烦吗？ 于是我开始找“node_modules”文件夹里面的源码。 谷歌的sitemap生成源码里： 是直接拿到hexo.config.sitemap，然后就是generator.js，这样绕进去找。得绕有点久。那先看看百度那边。 有戏，使用的不是同一个sitemap，然后在baidusitemap.ejs里面又读了一次url！ 那就好办了，在百度sitemap那里多写一个url就搞定了： 搞定，一次hexo g。两个sitemap的域名是不同的了。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>hexo源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown扩展]]></title>
    <url>%2F19markdownextend%2F</url>
    <content type="text"><![CDATA[本文分享markdown的妙用：插入本地文件。 前一篇博客，我插入了一个pdf文件。 实际上是这样写的： 还能这样写（使用html，并加入图标）： 12&lt;a id=&quot;download&quot; href=&quot;/contentimg/18/Office-2019.pdf&quot;&gt;&lt;i class=&quot;fa fa-download&quot;&gt;&lt;/i&gt;&lt;span&gt; Download PDF &lt;/span&gt;&lt;/a&gt; 这里也放一下pdf转html的一个网站吧，速度蛮快的： 迅捷PDF在线转换器 转化完下载下来是一个压缩包，解压放到工程中，然后到主配置文件修改： 提醒hexo忽略编译该文件夹。然后清理整个工程：hexo clean。再生成和发布，就可以使用了。 优化版 目前这个在移动端无法适配大小。而且如果每个pdf都拿去转html，效率一般般。如果只需要完成电脑端的查看，可以直接 1&lt;p&gt;&lt;div style="width:100%; height:950px;border:none;text-align:center"&gt;&lt;iframe allowtransparency="yes" frameborder="0" width="100%" height="800" src="filepath.pdf"/&gt;&lt;/div&gt;&lt;/p&gt; 这种做法，实际hexo有个插件已经集成自动转化这种代码。但是不推荐这种做法！理由是iframe+pdf原文件，在手机端打开，不是提示下载，就是提示不支持。 但是日常生活中，我们看到那些做得好的网站，是能在线浏览pdf的？都是后台转html？不是，这里有个开源插件：pdf.js下载 源码120+m，有兴趣的前端工程师可以去github下载来看。这个链接是已经build的。拿到手后，修改一些参数后就可以使用了。 要改的地方只有一个：找到示例中的pdf文件，删掉，同时在viewer.js脚本中找到这个文件的指向，删掉。 然后到配置文件设置不编译这个目录，重新生成，就可以启用了。使用方法是在src中，先定位到该viewer.html，然后传你要显示的pdf给它。这样在电脑端或者移动端，都是可以实时预览，而且下次引用也方便。只需要指定新的pdf目录即可。]]></content>
      <categories>
        <category>markdown扩展</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[office2019破解安装版]]></title>
    <url>%2F18office2019%2F</url>
    <content type="text"><![CDATA[本文分享破解吧看到的office2019的破解安装。 在这里得感谢破解吧。上面好多破解版软件。在此提醒大家，请用于个人学习，勿用于商业用途。 下面引用破解吧的教程： 原文地址 OTP地址 Download PDF]]></content>
      <categories>
        <category>软件破解包</category>
      </categories>
      <tags>
        <tag>office</tag>
        <tag>破解吧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github security alert 解决之路]]></title>
    <url>%2F17git-securityalert%2F</url>
    <content type="text"><![CDATA[本文记录我遇到github的“security alert”时，怎么处理解决。 邮箱收到这个警告的时候蛮懵的，因为代码什么的没改过。最近做的操作，就是手动修改了“package.json”，以及删除“package-lock.json”文件和“node_modules”整个文件夹。后面重新安装，npm正常跑起来，博客也能正常更新，怎么就突然发警告了？ 登陆git查看具体警告内容： 原来是提示需要更新插件版本而已。 那就手动更新吧： 1npm update XXX 不对，说好的添加文件的提示怎么没出来，直接就回车返回了？ 那强制更新到某版本 1npm update XXX@1.2.3 还是一样？那就只能用install了。 1npm install XXX@1.2.3 再次提交博客环境工程，这次git不报警告了。 最后贴一下“package.json”和“package-lock.json”关系的几个链接吧： 【前端】简单了解package.json与package-lock.json package-lock.json的作用 简单讲就是package.json负责安装我们需要的工具，package-lock.json着负责把那些工具需要的包记录安装起来。由于lock文件很大，东西很多，一般我们不会去看，所以这时候就会遇到一些依赖包版本过低的问题。]]></content>
      <categories>
        <category>github疑难杂症</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>security alert</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMWare安装Linux系统和mac系统]]></title>
    <url>%2F16VM_macandlinux%2F</url>
    <content type="text"><![CDATA[本文记录如何在VM虚拟机中装Linux系统和Mac系统。全文截图解说，打开会比较慢。 开头贴一下下载链接吧，版本有点老了： 百度云盘 提取码：y9y9 系统就不提供了，可以去msdn等等地方下载。 下面开始贴图说明安装过程： Mac安装 第一次装的时候，由于系统磁盘格式问题，会出问题： 所以得返回：（当然一开始就得先搞磁盘，再来安装才对） 注意中国在右边。 右下角，把光驱引用的文件定位到打补丁时增加的darwin文件。具体在安装目录下能找到。 CentOS安装 Linux的安装比较无趣。步骤也简单 这里得选择安装位置，才能下一步。]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>VMWare</tag>
        <tag>Linux</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可随身携带的windows系统]]></title>
    <url>%2F15SSDforwto%2F</url>
    <content type="text"><![CDATA[本文记录将SSD利用wto配置成可随身携带的系统。同时介绍一些SSD的知识。 开头贴一下百度百科。 Windows To Go Windows To Go是Windows 8/8.1、Windows 10的一种企业功能，被内置于Windows 8企业版、Windows 8.1企业版、Windows 10企业版、教育版与专业版（1607以后）中。对于满足Windows 8硬件要求的电脑，Windows To Go可使Windows 8、Windows 8.1、Windows10从USB驱动器中启动并运行，不必考虑电脑上运行的操作系统（2012款之前的Mac和Windows RT不被支持）。 Windows To Go的设计并不旨在代替台式计算机、便携式计算机，或取代其他移动产品。恰恰相反，它为有效使用备用的工作场所方案资源提供有力支持。 wto就是win8新版本开始提供的便携式系统，可以装在U盘上，然后随便找个主机插上去，就能登录这个系统进行使用。脱离了硬件上的捆绑。 个人建议最好弄成win10的，后面更新新版本那种。不过，按照我尝试后发现，首先得和你系统版本对应，并不是你去网上下载一个最新版就能使用的。我的win10是1703版本的，下载的包1803的就不能用，重启后进不了安装界面。 所以最好找你系统当时安装的那个包来做系统包。 启动wto的方式，在win菜单那里直接打“win”就会出来： 当然也可以去控制面板找。 下一步，选择iso。这里需要挂载一下iso，它才能识别到。不能直接定位到iso压缩包。 安装过程很简单。这里不记录。重点是这个U盘安装了这个后，会隐藏起来，在现在使用的系统中就不会显式显示出来： 不过既然还是能识别到，就可以使用，直接右键给它分配一个盘符就可以使用了。利用这个特性，就可以跳过登陆验证，直接获取电脑上其他盘的文件了。 这个方式比用PE取消登陆密码要好。又不会破坏原系统的东西。适合用于电脑卡在更新界面无法登陆时，用U盘系统启动，然后分配给C盘盘符，进去把更新的文件删掉；然后回原系统启动，就不会更新了。具体步骤可以百度。以前是只能去F8安全模式弄，现在可以直接U盘启动弄了，容易很多。而且是和U盘速度挂钩的，如果用SSD，那就是秒开了，挂在那些老电脑上完全满分。 下面介绍一下这个U盘的一些知识吧。我用的是SSD，所以特意查了下相关的东西。目前市面上，能达到直连效果的只有3.1的gen2。当然比较推荐圆头的那种typeC接口，就是手机上那种接口（注意，SSD还真能连在手机上用，驱动得起来）。 这里有个软件可以检测： aida 注意这里电脑USB口的影响也有的，软件里面会提醒。当能达到3.1最高时，是能和直连那样达到几百兆的传输速度的。 这个软件，密钥搜一下很多，可以直接用。不用破解。 当然也有个检测磁盘评分的，不过觉得不太适合，那个是直连时检测4K对齐等等参数的： 对WTO还是蛮看好的。随身携带，电脑那么重，现在却只用带个U盘就行，省力很多。而且如果用的SSD，挂在老电脑上，完全就是脱胎换骨。]]></content>
      <categories>
        <category>windows系统妙用</category>
      </categories>
      <tags>
        <tag>wto</tag>
        <tag>SSD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写bat自动备份博客到codingpage]]></title>
    <url>%2F14batforcodingpage%2F</url>
    <content type="text"><![CDATA[本文记录编写bat自动同步博客到codingpage。 由于gitpage在国内访问没codingpage快，我是把域名挂在codingpage的。但是博客和代码等等都在github那边，平时靠两边复制文件来同步，操作繁琐，便想到了用批处理来做这件事。 在github这边，用gitbash生成，提交好后，点击bat，将public目录下的同步到coding。需求是这样的。那怎么实现？ 方案一 新建文件夹codingpage，将public的文件复制到那边，然后提交。这里有问题，需要先清空codingpage文件夹，然后才能复制。写了一下del的处理，发现好麻烦，考虑的东西太多了。 所以方案一放弃。 方案二 还是新建文件夹codingpage，但是是用来init git，让它出来一个.git后缀的文件夹： 后面的操作就是把这个.git文件夹复制过去public目录，然后cd进public，git提交。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@echo offecho 'use SSH command，will pull public to coding page'set publicdir=D:\source\blogcode\public\.gitset publicd=D:\source\blogcode\publicset aimdir=D:\source\yaojiaxinpc\.gitecho aimdir is %aimdir%echo publicdir is %publicdir%echo d|xcopy %aimdir%\* %publicdir% /s /c /yecho doneecho ***********************************************echo ***********************************************echo ***************start to commit***************echo ***********************************************echo ***********************************************cd /d %publicd%echo gitdonedel CNAMEecho git pull origin masterecho but this useless because it's backups.so it won't done.git add .echo add all file to git...set "year=%date:~0,4%"set "month=%date:~5,2%"set "day=%date:~8,2%"set "hour_ten=%time:~0,1%"set "hour_one=%time:~1,1%"set "minute=%time:~3,2%"set "second=%time:~6,2%"if "%hour_ten%" == " " ( set cmitmessage=%year%%month%%day%0%hour_one%%minute%%second%) else ( set cmitmessage=%year%%month%%day%%hour_ten%%hour_one%%minute%%second%)git commit -m "%cmitmessage%"echo use time for message, commiting... git push origin master -f echo git push done!pause&gt;nul 对应git 该方案行得通，而且处理方式简单许多。下面记录一下过程中遇到的问题。 按照脚本从上到下来记录吧。 首先是定义变量： set 变量 引用 %变量% 然后是复制 xcopy，这里会遇到弹窗选择“文件”：“文件夹”的弹窗选择，所以手动加一下追加输入： d|XXXXX d是里面要输入的东西。 这样完成了将.git复制到public目录的工作了。得将运行目录定位到public目录。 cd /d XXXX codingpage那边不需要CNAME文件，所以删掉它。 del 文件 剩下的是git操作。 先用cmd实验一下git操作： 12git --versiongit config --list ①添加命令：“.”表示全部 git add . ②同步命令： git pull origin master ③提交命令：（后面还得推送才是完整的提交） git commit -m ‘注释’ ④推送命令： git push origin master 这里我用的是主线，可以根据需要进行修改。 那就简单了，直接复制过去批处理。 这里遇到的问题蛮多的： 批处理里面不能写多余的空格，特别是路径和变量定义。因为会完整识别出来空格并运用，导致出问题。 git commit不加注释，就强制进入VIM模式。所以得加。 单引号 和 双引号 的区别，刚开始一直报错当前文件夹没有可提交的东西，排查到是commit出错，后面排查出来是引号问题。 这里搜到一篇比较完整的git批处理：bat文件方式对git进行操作 以及面对VIM模式：在git bush中如何退出vim编辑器 还有运行该bat后，github desktop无法提交，提示：failed to receive handshake 其实只要注销重新登录就行的，不过我就去改配置文件，删掉用户信息，提交一遍，再加回去，就正常了。 写在最后 后来发现，其实改配置文件，hexo d的时候能两边一起提交的！ 123456deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch]]]></content>
      <categories>
        <category>批处理</category>
      </categories>
      <tags>
        <tag>批处理</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改蜘蛛网悬浮于顶层]]></title>
    <url>%2F13jsclickpass%2F</url>
    <content type="text"><![CDATA[本文记录我如何修改当前主题NexT中引用的canvas-nest的一些细节。 默认NexT主题，蜘蛛网是跟随鼠标运动的，但是我感觉那样不好玩，如果静置的话，会变成一个圈，不好看。然后我浏览了一下整个目录结构，找到 看到有canvas-nest 还有fancybox 。 canvas-nest：蜘蛛网的实现js代码。 fancybox：淡入淡出功能模块。 于是我就想到把蜘蛛网的鼠标部分代码去掉。引入fancybox的淡入淡出动画，点击的时候出现“赞”的图标。 “赞”部分的代码如下： 12$(document).bind(&quot;click&quot;,function(e)&#123;var $i = $(&quot;&lt;a style=&apos;border:none;border-bottom:0px&apos;&gt;&quot;).prepend(&quot;&lt;img src=&apos;/images/redhand.png&apos;/&gt;&quot;);var x=e.pageX,y=e.pageY;$i.css(&#123;&quot;z-index&quot;:99999, &quot;top&quot;:y-15,&quot;left&quot;:x,&quot;position&quot;:&quot;absolute&quot;,&quot;color&quot;:&quot;red&quot;&#125;);$(&quot;body&quot;).append($i);$i.animate(&#123;&quot;top&quot;:y-180,&quot;opacity&quot;:0&#125;,1500,function()&#123;$i.remove();&#125;);e.stopPropagation();&#125;); 然后又想到把蜘蛛网放到顶层 zIndex=99 结果发现这时候鼠标不能选中代码和文字进行复制了。推测是canvas层挡住了，所以得给它设置穿透： pointer-events:none; pointer-events]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>canvas-nest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown内嵌html文件]]></title>
    <url>%2F12hottoaddhtml%2F</url>
    <content type="text"><![CDATA[本文记录如何在Markdown内嵌html文件，并设置hexo忽略编译该html。 前面一篇博客，我在页面里面嵌入了一个时钟html文件。 到底如何实现的呢？ 刚开始，我是直接引用下面这样的代码： 12345&lt;p&gt; &lt;div style=&quot;width:100%; height:350px;border:none;text-align:center&quot;&gt; &lt;iframe allowtransparency=&quot;yes&quot; frameborder=&quot;0&quot; width=&quot;300&quot; height=&quot;300&quot; src=&quot;/contentimg/11/click.html&quot;/&gt; &lt;/div&gt;&lt;/p&gt; Markdown可以插入外部html：利用iframe标签来实现。 实际上，这样还是不行，hexo会自动给该html添加框架的代码，导致实际的效果变成主页嵌套该html代码。 刚开始没头绪，后面对比文件大小。 打开看到是加入了框架的代码导致。所以这时候要解决的是怎样让hexo编译的时候忽略该文件不加入框架代码。 还好hexo也考虑到这个问题： 1234skip_render: - contentimg/11/click.html - 404/404.html - README.md 在这里添加需要忽略编译的文件或文件夹。包括README.md也能这样弄，就不用像我前面的优化博客中提到那样在gulp里面操作复制文件了。 文件夹的话是/*。注意设置完后，需要hexo clean，再hexo g。才能看到效果。不然直接hexo g，是不起效的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>skip_render</tag>
        <tag>Markdown内嵌html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown内嵌前端代码实例--时钟挂件]]></title>
    <url>%2F11clock-js%2F</url>
    <content type="text"><![CDATA[本文分享一个时钟挂件实例。该部分代码是网上搜索复制来的，非本人版权，请勿用于商业用途。 这里利用iframe引用外部html，同时设置 allowtransparency=”yes” frameborder=”0” 让iframe的背景透明，边框消失。 div style=”width:100%; height:350px;border:none;text-align:center” 但是此时的iframe是靠左上的。我想居中，就需要利用div来实现。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>时钟挂件</tag>
        <tag>Markdown内嵌前端代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg-简单AES加解密记录]]></title>
    <url>%2F10ffmpeg-aes-1%2F</url>
    <content type="text"><![CDATA[本文记录如何将浏览器中的视频缓存文件合并成一个mp4文件。该方式使用ffmpeg。视频片段为m3u8格式。 视频分段缓存技术之中的一种格式m3u8，据说是苹果开发的。而这里由于有ffmpeg工具，运用起来很快捷，当然也可以自己写代码集成一个播放器。本文暂时只记录简单的运用ffmpeg工具加解密和播放。代码集成等后面有空再分享。 观摩这项技术时参考的几篇文章分享如下： 使用ffmpeg转码m3u8并播放 hls协议（最清晰的讲解） 流媒体开发之–HLS–M3U8解析(2): HLS草案 ffmpeg Cheatsheet 使用ffmpeg视频切片并加密 ffmpeg分解视频文件并加密 FFmpeg之ffplay命令使用 还有一些cmd操作： CMD批处理循环，太强大了 copy /b 命令无缝合并多个文件 当然还有其他很多参考过的网页，但是都很散，有用信息不多，暂不分享那些网页。 这项技术运用在很多浏览器上，所以想找东西练手，还是蛮多的（某些想下载但是没提示下载的视频，实际上是放在缓存文件夹里面，然后本地加载拼起来的）。 这里我就简单分享一下如何自己用ffmepg对一个视频加密，以及解密该视频。 目前我接触到3种情况： 未加密的视频，用PotPlayer可以直接打开观看； 有AES的key，没IV（其实就是使用了默认值），部分有两个m3u8； 有AES的key和IV，就是下面将要分享的操作。 目前要使用的工具，首先必须要有ffmepg ，下载成已经Build好的包，不然自己来生成比较麻烦，当然，有兴趣可以下载代码来看，是开源的。 生成key部分我使用了Openssl ，功能超级多，但是本文只用到简单的生成随机密码。好像是我下载不对，操作发现不支持hex，所以后面生成hex部分得写一下代码处理，当然也有网页生成，数据库生成，这里就不写明了。 然后就是准备一个视频。我这次下载了这些东西： 接下来就开始动手：（实际不用Openssl也行，直接手动写几个编码当密码就行） 通过上面推荐的链接，大家应该知道是主要m3u8文件，然后附带的ts文件（可以不写后缀，就是些视频片段，可以在播放器中打开观看），key（会改变视频片段的编码，导致无法播放）。 这里的m3u8可以用播放器打开，正常是会报错的，因为视频片段被AES加密了编码模式，所以普通读取出来不是正常的头，就报错了。 如果你遇到的m3u8没有加密，那这里是打开可以播放的。上面那些ts也是可以直接播放器打开的。 一般情况下，m3u8文件可能需要进行修改。就是当你操作的是手机端，把缓存搞在电脑上转码时（或者从C盘缓存目录拷贝出来时），里面的路径是不对的，里面记录的是绝对路径，需要修改。像下面图片，手机拷过来后是手机上的绝对路径，用记事本ctrl + H，该成电脑上的当前路径后就能用了（或者删掉变成相对路径）。 现在从头开始做吧。 目前我们手上只有一个test.mp4，先介绍不加密的方式分段生成m3u8。 无加密方式生成m3u8 新建一个文件夹来放置后面要生成的ts文件。 先用管理员身份运行cmd： cd到ffmpeg.exe所在的地方（不过我推荐是cd到要生成文件的地方，然后ffmpeg.exe弄成全路径来执行，效率会高一些）。 例如我test.mp4在D:\aa\bb目录下： 这样我在cmd中输入： 1ffmpeg.exe -y -i D:\aa\bb\test.mp4 -hls_time 6 -hls_playlist_type vod -hls_segment_filename "D:\aa\bb\file%d" D:\aa\bb\playlist.m3u8 -hls_time 是每一段视频多长时间 -hls_segment_filename 分段生成在哪里，命名规则%d 以及结尾的m3u8输出路径 目录下已经生成分段文件+m3u8文件了，由于这里没有加密，所以分段文件可以用播放器直接打开。当然也可以直接打开m3u8文件。 这里插播一下ffplay的使用： 指令中要注意的就是路径，从前面我们知道是m3u8中记录是用相对路径，所以需要把cmd移到该目录下，然后用ffplay的全路径 + -allowed_extensions ALL （就是允许全部后缀模式，否则没后缀的不让播放） +m3u8 + 回车 1D:\aa\ffmpeg-4.0.2-win64-static\bin\ffplay.exe -allowed_extensions ALL playlist.m3u8 既然提到分段，那就有合并了。 由于这里没有使用加密，所以可以直接把全部ts文件合并成一个文件就行。 可以cmd直接合并，但是需要提前处理命名规则，因为cmd按字符比较的，01和1是两种不同的概念，这里可以写个循环处理改命名，然后再用cmd的copy /b * new.mp4。 cmd代码不好写。所以推荐还是用ffmpeg。 代码如下：合并并转码成mp4格式1D:\aa\ffmpeg-4.0.2-win64-static\bin\ffmpeg.exe -allowed_extensions ALL -i playlist.m3u8 -acodec copy -vcodec copy -f mp4 output.mp4 加密方式生成m3u8 有了前面那些截图，这里的操作其实就是多了写密码步骤而已，其他大部分一样，所以这里就不再截图了。 加密，目前我看的是AES。概念那些大家有空去了解一下，这里只分享一下怎么用。 具体步骤是：使用ffmpeg视频切片并加密 然后里面一些参数，其实在源文件里面已经有了，可以找这些文档来弄明白设置什么参数： 这里我多分享一下直接用一个key来加密怎么操作吧。就是手上有一个密码+一个视频，弄到最后是一个放密码的文本文件，然后就是ts+m3u8，没有IV。 其实就是前面步骤中，enc.keyinfo中第三行的IV删掉就行。 同时步骤一中用openssl生成key的，改成：新建文本文件，写入密码后保存，然后删掉后缀当key。 其他照旧： 1D:\aa\ffmpeg-4.0.2-win64-static\bin\ffmpeg.exe -y -i test.mp4 -hls_time 6 -hls_key_info_file k0.keyinfo -hls_playlist_type vod -hls_segment_filename "file%d" playlist.m3u8 密码文件k0，用openssl生成的话，打开是乱码的，自己写入的就不会乱码，使用起来暂时未发现区别： 加密方式生成的ts文件，你会发现无法用播放器打开，只能用ffplay打开（打开方式同无加密一样的代码，都是直接传入m3u8文件即可）。 这样解密方式，实际也和前面一样，都是围绕m3u8，是否有key，实际都是内部处理的。 这里可能会遇到问题的是，网上的都是说EXT-X-KEY这里的是http，实际都可以，找得到文件就行。然后就是开头提的两个m3u8的，这个就溜一点： 改EXT-X-KEY的文件地址为key的本地地址后，发现这样去转是失败的（提示找不到ts文件），这时可以把下面的一堆ts信息，换成另一个m3u8里面的ts信息，就可以转换了。我遇到的情况，是第一个ts信息是本地文件，第二个是一个找不到的路径的文件（但是这个带key，第一个不带），修改成本地文件后，除了#EXTINF的数字不同外，其他都一样（文件也能找到了），结果还是报错，就把那个m3u8的ts信息都复制过来（#EXTINF的数字保持一样），本个m3u8只保留EXT-X-KEY这里的URI=”k0”，其他都是用另一个m3u8的，就可以转换了。]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>视频处理</tag>
        <tag>工具使用</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客心得---配置主题Next]]></title>
    <url>%2F9howtoeditthemes%2F</url>
    <content type="text"><![CDATA[本文是记录如何修改配置Next，增加百度统计功能、评论区、RSS、爬虫等模块。是在前面几篇文章的扩展记录。 注意这些第三方插件，当我们的博客布在github和coding两边时，数据是可以共用的！只要id和key是同样，在服务供应商那边记录域名和网站后，就可以顺利共用数据。 Next的使用说明 开头先贴官方配置说明。这里的头像位置、昵称等等，请通过这个官方配置说明链接来配置。本文只分享官方文档里面难的部分，以及文档里面没有的部分。记住配置文件“：”后面需要打空格，然后才加内容！ 注意，打开这些第三方服务，会拖慢网站打开速度，请酌情使用。 官方指导链接 评论系统&amp;文章阅读量统计功能 因为文章访问数量那个系统我用的leancloud ，发现配置文件里面刚好也支持它，我就也用的这个服务。 官方文档里面有提到这个阅读理解统计的： 为NexT主题添加文章阅读量统计功能 一起凑合着看吧。由于它支持我们改数据，所以我就使用它了。（没事可以偷偷上去改个阅读量999999！） 注意，第一次创建应用，在这里添加class，需要等2分钟，所以要耐心等。另外，免费版的，不能删除class，所以别加太多了。注意这里：评论的是Comment，文章阅读量的是Counter。 然后就是去获取key和id。这里不能直接鼠标拉选，不过可以右键，定位到元素，然后在代码里面找到这个字符串，就能复制了。 最后，千万记得要去“安全中心”设置“web安全域名”！因为这个id和key是明文，谁都能抓取到的！ 还可以设置邮件提醒Valine 评论系统中的邮件提醒设置 百度统计 文档里面说得很简略，下面我就介绍一下详细的过程。 怎么打开？ 先在百度统计那边复制key，然后到配置文件里面ctrl f找到baidu_analytics 字段，打一个空格后把key复制进去。hexo clean，再生成，让html重新编译，会自动加代码进去的。 如果不会，可以直接发布。然后到百度统计那边检查。 内容分享服务 第一个JiaThis，搜索有新闻说已经关闭分享服务了。第三个好像是国外，搞推特的，国内访问应该比较慢，也不考虑。后面找了Mob，但是不支持https，所以也用不了。 剩下一个百度，结果，打开后发现很丑，还只能分享图片，不能整篇文章分享（得改代码）。所以我就没开该项。请自取哈。 分享的效果也不好，点击后调整的界面不好看。 字数统计&amp;阅读时长 里面已经内置了，开启就能使用了。但是单纯改配置文件，数字是显示不出来的，得添加插件： npm install hexo-wordcount –save -dev 安装完成后，hexo clean；hexo g。启动服务就能看到效果了。如果想像我这边一样加文字： 到目录：/themes/next/layout/_macro/post.swig 用记事本打开后搜索post_wordcount： RSS npm install hexo-generator-feed –save -dev 然后到主配置文件最底下添加： 12345678# Extensionsplugins: hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20 这个插件的作用是统计记录你的文章，生成一个xml格式的文件atom.xml。别人通过订阅分析你这个文件变动来了解你文章的更新情况。 百度sitemap npm install hexo-generator-baidu-sitemap –save -dev 在百度里面搜索site:域名。检验是否被百度收录。如果没有的，需要进行登记。这里google的操作比较简单。 百度的，由于被github屏蔽爬虫，所以只能考虑放coding上面。coding的免费玩家，是会强制301转址的，所以这时候放百度验证，是无法成功的，百度验证不会像浏览器那样跳转识别，在说明那里也提到：“如果存在转址，请暂时取消”。 那怎么玩？只能想办法完成这个coding要求了。加图标的话，布局上没想到怎么改。所以我选择加文字版： 刚开始还去翻代码，结果发现原来NexT考虑到这个问题了，直接给我们加在配置文件里面，只需要去设置这个属性就行，不用改代码。 这里会遇到一个问题，当你把coding那边那个代码复制过来时，hexo g会报错！原来是由于没换行的概念，hexo读配置属性，是根据“：+空格”来判断的，所以只需要把那个空格删掉，它就不识别成属性，就不会报错。 接下来就是等通过验证然后来搞百度收录了。 百度收录链接 收录前需要进行的验证网站所有权 。就是上面提到的验证。 这里有三种方式可以做到：挂文件/在html加代码/CNAME。推荐第一种，因为第二种就直接明文了。当然，最后我还是用了第三种，CNAME，只需要去dns服务商那边设置就行了，马上就生效了，不用等coding过检。 挂文件 就是把密码文件下载下来后，放在source根目录，然后到主配置文件找skip_render属性： 12skip_render: - baidu_verify_XXXXXX.html 防止hexo添加代码到该密码文件，百度爬虫才能识别到该文件。 加代码 找到文件\themes\next\layout_partials\head.swig。然后直接在这里的空白处插入代码。 百度统计那边功能蛮多的，不过现在博客暂时还没收录，等收录后体验下其他的功能。 在配置好后，到配置文件启用： 12baidusitemap: path: baidusitemap.xml 再到百度提交收录： 建议开启百度自动推送，就sitemap左边那个。代码已经集成在Next了，只要开启主题配置文件的属性“baidu_push”： Google收录 npm install hexo-generator-sitemap –save -dev 开vpn，Google站长工具 类似百度收录的操作，都是下载密码html文件，放在根目录，然后到主配置文件添加忽略编译属性。 好处是github没有屏蔽google，所以直接用github那边的挂谷歌。而且他们都是国外的，所以挂github的话，比挂国内的coding对搜索排名要有利。 在配置好后，到配置文件启用： 123#sitemapsitemap: path: sitemap.xml 同样要去提交收录。但是超级快，一下就能在谷歌搜索到了。 其他第三方服务 到该目录下，列了目前NexT集成的第三方服务，可以根据文件名来选择要不要开启，都是在配置文件里面能找到开启选项的。其实这里的作用，就是把全部js脚本放在这里，然后用一个配置文件属性，判断要不要加这个脚本到html里面。 其他优化 第三方的东西我目前只加了这些，其他就是代码上的修改了。 文章末尾添加“—end—” 打开themes\next\layout\ _macro\post.swig，找到“wechat_subscriber”的地方，这个就是文章结尾时，“请加我好友”的图标所在的地方。复制如下代码： 123 &#123;% if not is_index %&#125;&lt;div style="text-align:center;color: #ccc;font-size:20px;"&gt;-------------------------------------------------------- The End --------------------------------------------------------&lt;/div&gt;&#123;% endif %&#125; 这里文字大小和长度，请根据自己喜好进行修改。 或者是使用hr写法。注意这里文本文字在DIV中垂直水平居中显示 123 &#123;% if not is_index %&#125;&lt;div style="height:85px;line-height:85px;text-align:center;color:#ccc;"&gt;&lt;hr size="7" color="coral" style="vertical-align:middle;float:left" width="40%"&gt; The End &lt;hr size="7" color="coral" style="vertical-align:middle;float:right" width="40%"&gt;&lt;br style="clear:both"/&gt;&lt;/div&gt;&#123;% endif %&#125; 但在手机端效果不行，换行了。 取消打赏的文字摇晃 自带的摇晃太魔性了，建议去掉。到位置：next/source/css/_common/components/post/post-reward.styl ，搜“animation”： 1加“/* */” 浏览页面的时候显示当前浏览进度 到主题配置文件，搜scrollpercent，改为true。 还可以放到左边：修改scrollpercent上方的b2t为true。 fork me on github右上角 到GitHub Corners 选择喜欢的样式，复制代码。然后定位到next/layout/_layout.swig，搜索headband。将代码贴在下面： 左上角 到Fork_me_on_GitHub 选样式，像上面一样操作。当然也可以自己根据实际情况微调。 将标签前缀“#”换为图标 到next/layout/_macro/post.swig，搜索 1rel="tag" 1将 #号 换成&lt;i class="fa fa-tag"&gt;&lt;/i&gt; 添加加载页面 在next的配置文件搜“pace-theme”：这里我这个是pace-theme-center-atom，还有其他一堆可以选。 添加站内搜索 npm install hexo-generator-searchdb –save 这里可能下载不下来，按照我前面说copy怎么下载那样，在npm失败后，会显示一个html，拿到百度云离线下载，下下来后，用记事本打开，搜version，找到最新版本，然后看barl的下载链接，再复制到百度云离线下载，然后当做本地文件来安装，就能安装了。 到主配置文件最后添加： 123456#表示站内搜索search: path: search.xml field: post format: html limit: 10000 然后到NexT配置文件搜索“local_search”，启动enable： 修改访问URL路径 默认情况下是年月日一串很长的url路径。是在主配置文件进行的修改：搜索“permalink” permalink: :category/:title/ #分类/标题 添加文章置顶功能 现在应该都是新版本了，所以直接介绍新版本的方式： 先卸载老插件，然后装新插件： 12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save -dev 然后在文章开头加 “top: 数字” 这样就能看的效果了。不过推荐加一下置顶图标在前面： 打开next/layout/_macro/post.swig，搜索1&lt;div class="post-meta"&gt; 然后加入如下代码： 12345&#123;% if post.top %&#125; &lt;i class="fa fa-thumb-tack"&gt;&lt;/i&gt; &lt;font color=#222&gt;置顶&lt;/font&gt; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&#123;% endif %&#125; 添加coding部分的一键复制功能 本博客没启用该功能，具体请访问该链接：添加coding部分的一键复制功能 由于有中文，该链接通过中文转码处理，如果失效，请通过域名查找。 添加Robot和nofollow 新建robots.txt文件在source根目录下： 123456789101112131415161718192021#hexo robots.txtUser-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/Allow: /about/Disallow: /404/Disallow: /contentimg/Disallow: /css/Disallow: /images/Disallow: /js/Disallow: /lib/Sitemap: http://yaojx.net/search.xmlSitemap: http://yaojx.net/sitemap.xmlSitemap: http://yaojx.net/baidusitemap.xml 当没这个文件时，默认全部内容可以爬，这个文件就是告诉那些可以爬，那些不行。 npm install hexo-autonofollow –save 当文章中有链接时，爬虫会顺着链接爬出去。所以得加这个nofollow。 安装完后，到主配置文件最底下添加： 1234nofollow: enable: true exclude: - yaojx.net 然后就是去百度站长提交robot文件了。 qq点击后直接开打联系我的窗口 该功能使用的是腾讯的开放接口： 1http://wpa.qq.com/msgrd?v=3&amp;uin=659771655&amp;site=qq&amp;menu=yes uin改成自己的qq就行了。 压缩gif 通常录屏文件要好几M，会导致网页加载严重缓慢，这里就需要进行压缩了，但是不建议进行脚本压缩，建议一张一张根据实际情况压缩。 这里需要安装gifsicle。国内资料比较少，这里有个说明文档 。 npm install gifsicle –global 目前我会用的功能比较少，主要使用了压缩色调： gifsicle -o3 1.gif -o 4.gif –colors 32 gifsicle -o3 需要压缩的文件 -o 输出的文件名 –colors 数字 通常情况下，录屏产生的gif是256色调的大体积文件，可以通过压缩成128、64、32、16等等色调，达到体积变小的目的。具体情况可以压缩试试看效果。这个操作是通过丢弃部分颜色值，达到压缩的效果的，所以色调越低，压缩越多，当然，照片也就失真越明显。 pdf显示 目前大家做这个博客，应该大部分会把自己的简历放上去，那是放html文件？绝大部分是pdf文件的。但是要怎么处理这个pdf文件的显示？用js代码，插入iframe，电脑端是可以的，但是移动端不支持，会直接提示下载文件。实际上有个开源前端插件，可以直接使用。可以看我另一篇文章，有提到markdown扩展 这里有几篇文章是讲怎么修改整个主题的，重点推荐：基于Hexo搭建个人博客——进阶篇(从入门到入土)Hexo搭建GitHub博客—打造炫酷的NexT主题–高级(四)Hexo+Next个人博客主题优化]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>个人博客</tag>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客心得---个人站点yaojx.net的优化之路]]></title>
    <url>%2F8SupGitPage%2F</url>
    <content type="text"><![CDATA[本文是记录配置域名转址，以及如何优化gitpage访问等等高级功能的文章。该系列有3篇：1.付费虚拟云主机+WordPress；2.免费github+Hexo；3.个人站点yaojx.net的优化之路。 整个优化非常坎坷，最后总结，才发现部署到coding就已经达到了优化中的99%。剩下这个1%，花了我99%的时间和精力。 本文不废话怎么排查，从什么地方入手。直接根据我优化中的体会来讲。 一.转址1.1 理解转址域名解析中A记录、CNAME、MX记录、NS记录的区别和联系 从DNS到github pages自定义域名 – 漫谈域名那些事 上面这两篇文章讲得很详细，介绍了DNS配置中几个选项间的关系。 转址的作用，就是当我在浏览器输入A的时候，浏览器自动帮我跳转到B网站（A方式），这里CNAME还添加了将B网站的前缀域名修改为A网站的效果（可配置，当没设置该项时就不会修改域名）。 一般情况下，我们只需要设置两个A方式（带www的，和不带www的），然后在page那边设置CNAME。 1.2 GoDaddy转址 这里GoDaddy给我们设置了一个基础的转址，但是不是很好用(起作用慢)。推荐是去修改上面DNS管理。 这里我就不截图了，默认项可以保留，默认有几个A和几个CNAME。直接添加新选项，然后TTL设置为自定义“600”。其他默认项暂时没必要删除。 12A @ 目标ip地址 //@ 相当于 yaojx.netA www 目标ip地址 // 如果没这一项，网站就是www.yaojx.net了 注意TTL设置600最小见效才快。不然得等好几个小时。 1.3 dnspod转址（即现在的腾讯云服务） 这个不用记录了，直接有“一键”的。就是输入两个ip就行，默认“一键”后，给我们创造了两个A类型的，一个是“www”，另一个是“@”。 这里提一下怎么找gitpage和codingpage的ip： 直接ping网站，注意这里github的IP会左右变动。但是不影响我们使用A方式转址。图中ip没一致，但是仍然可以转址成功。 1.4 GitHub相关配置GitHub自定义域疑难解答 coding那个就不用说明了，和腾讯一样都是一键的。 GitHub这边要弄的东西不复杂，就添加一个文件CNAME ，注意没有后缀，五个字母都大写。里面放的是你要跳转的域名。 该文件一创建马上生效，你访问YaojiaxinPC.github.io就会跳到CNAME里面的域名yaojx.net然后又回来YaojiaxinPC.github.io，当然这时候前缀已经改为yaojx.net了。（这个过程可以在chrome中捕捉到，所以修改转址后，直接访问YaojiaxinPC.github.io反而耗时。） 这里遇到的坑是，刚开始使用GoDaddy，后面改cloudflare，因为都在国外，转址更新见效慢，域名那边没转址对YaojiaxinPC.github.io，导致跳过来gitpage后，是个404，访问YaojiaxinPC.github.io这边，又已经转址到yao.net–&gt;404，构不成一个环。卡了好久，等几个小时后，DNS同步到了后才见效。 coding那边就不用，一设置就见效。所以后面我域名都放到DNSPOD上了。 二.优化工具2.1 百度统计 分析优化内容 里面提到的合并js，以及Gzip压缩，都要改大量代码，所以这两项目前我还没去弄。只根据未优化前期提的建议，使用了后面提到的gulp压缩工具而已。同时前期还有提到头像文件太大等等其他建议（头像后面我改成170X170）。 2.2 Chrome调试工具使用 未优化前期，用Chrome打开，一直提示加载过慢（5S以上），使用默认字体代替，同时提示是ttf文件下载太久。当时就把我引到优化字体的方向上，后面追查了好长时间，发现搞错了。重点在DNS解析和IP。当然，如果有用谷歌字体，这里会有问题的，谷歌被墙，所以在next主题中最好使用本地字体，搜索有提到用360库的，还有github上的ed链接等等那些，效果都一般，还是不使用这些字体好。 还有其他一些统计工具，不过实际Chrome的调试工具就已经能完成那些统计了，就不推荐那些工具了。 2.3 站长工具 第二个图是更新了文章后截的图，大小上是大了一点点（其他东西都是和coding那边一样的），都是使用手动gulp优化后的Gzip压缩（文件只是体积变小，百度统计认的gzip是后缀为gz的压缩文件，意思不同）。但是在上面图中识别出来是不同：codingpage的直接压缩率99.96%？？？同时识别不出来gzip压缩。这样就能解释怎么放那边打开是秒开了。 三.Gulp压缩 这个是重点，让整个包从15.7m压缩到11.7m。而且整个操作除了安装工具，写一个js脚本 外，不用修改工程中的任何东西和代码。不会对原工程造成影响！ npm主页 3.1 安装gulp1npm install &lt;name&gt; [-g] [--save-dev] name：node插件名称。例： npm install gulp –save-dev -g：全局安装。将会安装在%homepath%\AppData\Roaming\npm，并且写入系统环境变量； 非全局安装：将会安装在当前目录的node_modules文件夹下，只能在当前目录通过require()调用使用。 全局安装：可以通过命令行在任何地方调用它。 –save：将保存配置信息至package.json（package.json是nodejs项目配置文件）。 -dev：保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点。 配置文件package.json记录了当前工程使用的相关包，只需要在有这个文件的文件夹下面执行“npm install”，就会根据package.json下载所有需要的包。 1234567891011npm install gulp --save-devnpm install gulp-htmlclean --save-devnpm install gulp-htmlmin --save-devnpm install gulp-imagemin --save-devnpm install gulp-minify-css --save-devnpm install gulp-uglify --save-dev//文件处理npm install del --savenpm install mv --save//这个网络情况不是很好，所以最好通过设置配置文件的skip_render来避免处理README.mdnpm install copy --save 3.2 编写gulp脚本 gulp脚本 可以使用我github上的这个脚本。里面做的事情就是压缩html、css、js、图片等，在我电脑上，无法进行覆盖操作，所以我就把生成的压缩文件保存到缓存文件夹，然后用del/copy/mv等操作来处理。 注意hexo编译的时候，会把后缀为“md”的文件都转成html，所以README.md也会变成README.html。这样，就不能把它放在source里面，只能放外面，在gulp后再复制进去public中。(其实这里可以通过设置主配置文件的skip_render来避免编译) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495var gulp = require('gulp');var del = require('del');var mv = require('mv');var copy = require('copy');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin'); // Clean 任务执行前，先清除之前生成的缓存文件gulp.task('clean', function(cb) &#123; return del(['./public1/**'], cb)&#125;);// move 任务执行完成后，从主目录复制文件过来缓存目录//(此时会自动删除主目录),然后再复制回去（因为不能覆盖，所以不能从缓存目录直接过去主目录进行覆盖）gulp.task('filedone',['copy-all'],()=&gt;&#123;gulp.start('filedone-dealREADME');&#125;);//将public下的文件复制到缓存文件夹下gulp.task('copy-all', function(cb) &#123; return mv('./public', './public1',&#123;clobber: false&#125;, cb)&#125;);//复制README.md。处理完成后才进行重命名gulp.task('filedone-dealREADME',['copy-readme'],()=&gt;&#123;gulp.start('backcopy');&#125;);//复制README.mdgulp.task('copy-readme', function(cb) &#123; return copy('README.md', './public1', cb);&#125;);gulp.task('backcopy', function(cb) &#123; return mv('./public1', './public',&#123;clobber: false&#125;, cb)&#125;);// 压缩htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public1'))&#125;);// 压缩cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss(&#123; compatibility: 'ie8' &#125;)) .pipe(gulp.dest('./public1'));&#125;);// 压缩jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public1'));&#125;);// 压缩主题图片gulp.task('minify-images', function() &#123; return gulp.src('./public/images/**/*.*') .pipe(imagemin( [imagemin.gifsicle(&#123;'optimizationLevel': 3&#125;), imagemin.jpegtran(&#123;'progressive': true&#125;), imagemin.optipng(&#123;'optimizationLevel': 7&#125;), imagemin.svgo()], &#123;'verbose': true&#125;)) .pipe(gulp.dest('./public1/images'))&#125;);// 压缩文章图片gulp.task('minify-contentimg', function() &#123; return gulp.src('./public/contentimg/**/*.*') .pipe(imagemin( [imagemin.gifsicle(&#123;'optimizationLevel': 3&#125;), imagemin.jpegtran(&#123;'progressive': true&#125;), imagemin.optipng(&#123;'optimizationLevel': 7&#125;), imagemin.svgo()], &#123;'verbose': true&#125;)) .pipe(gulp.dest('./public1/contentimg'))&#125;);//压缩字体文件（实际没看出效果）gulp.task('fontttf', function() &#123; gulp.src('./public/lib/font-awesome/fonts/*.*') .pipe(gulp.dest('./public1/lib/font-awesome/fonts'));&#125;);//build完后复制文件回去gulp.task('build', ['minify-html','minify-css','minify-js','minify-images','minify-contentimg','fontttf'],()=&gt;&#123;gulp.start('filedone');&#125;);// 执行清理任务后才buildgulp.task('default', ['clean'],()=&gt;&#123;gulp.start('build');&#125;); 3.3 当下载不了工具怎么办 npm是一个前端自动化工具。有中文官网，但是网络很不好，同时我们在gitbash里面操作下载，也经常因为网络问题下载不了。 后面排查分析，了解到gitbash里面的install操作，实际上是去github上找最新版本down下来。所以如果遇到安装的时候报联网失败，是可以分析找到github上对应的包，直接下载来安装的（npm的服务器ping经常断流，不是墙的问题）。 在install失败的时候，会提示“XXX网站”连接失败，这时候把这个网站复制到百度云离线下载，是能下载下来的： 打开后找version，拉到最下面，找到最新的一个版本后，找下载链接tarball。然后用百度云离线再下载下来。放到D盘根目录： npm install d:/XXX.tgz 如果还不行，就直接手动解压，放到node_modules目录吧。 这里贴几个npm的介绍博客链接吧： 前端自动化gulp遇上es6从 无知到深爱 前端自动化构建工具gulp记录 npm 模块安装机制简介 另外，在github下载别人的博客代码后，可以通过cmd cd到目录下，直接npm install就行，会默认自己找package.json来安装。注意看一下里面的结构，联网下载的是有前缀^，本地文件的是相对路径。 package-lock.json影响不大，可以删除。当安装package.json时，会重新生成。 四.总结 划重点，其实如果你部署在codingpage上，本篇文章就不用看了。因为都是秒开的。 部署在github上，逼格虽然高了些，但由于服务器在国外，而且没自带加速，优化之路很麻烦：压缩+CDN加速。 而压缩，其实就是牺牲cpu解压换来的。目前使用gulp进行初步压缩。复杂的可以直接压缩成gz文件来处理。 在我认为，js文件压缩就没必要了，合并js文件还可以，压缩就没必要。图片方面是主要优化对象，而这里，其实还有个七牛云 七牛在国内，访问比github快。而且每月有10g的免费额度。 注意，这里page的优化，DNS解析权重最大，所以上面提到的合并js，其实就是避免来回的dns解析请求。而IP，github服务器在国外，访问相对国内的coding会慢好多。 由于整个page是静态文件，所以好多技术性上的优化（缓存），权重是很小的。]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客心得---github+Hexo]]></title>
    <url>%2F7CreatGitPage%2F</url>
    <content type="text"><![CDATA[本文是记录如何安装环境，发布初版个人GitPage网页。该系列有3篇：1.付费虚拟云主机+WordPress；2.免费github+Hexo；3.个人站点yaojx.net的优化之路。 这个比较好玩，逼格高好多，网速也快了好多。是利用GitHub的GitPage 技术，把自己通过Hexo工具编译出来的静态html文件放在帐号共享项目中，就能让别人通过“用户名.github.io”固定连接来访问你的这些html网页。后面加上DNS转址功能把那串固定连接隐藏掉，基本别人就看不出来你这个网站是主机承载还是gitpage了。 一.环境准备 首先当然是：注册GitHub 帐号，当然，国内的Coding 也行，就是Coding Pages 。最终我采用的方案是布到GitHub，同时备份一份到Coding，国内访问就用Coding，ping只有50，秒开。GitHub优化到最后，DNS解析始终突破不了，因为它的服务器是在国外。 1.1 安装Node.js Nodejs官网 Nodejs下载 Nodejs安装教程 1node -v 1.2 安装Git Git下载 安装完成git后，在桌面创建一个快捷方式，这时候点击启动后，里面的路径会是C盘下的。为了使用方便，我们是希望它直接cd到博客所在的目录，可以按照下面这样改：删除“–cd-to-home”、“%HOMEDRIVE%%HOMEPATH%”；添加博客目录到“起始位置”。 检验安装情况： 1npm -v 我当时遇到“bash: npm: command not found”。后面搜索到是没安装好，只能在cmd下使用，需要在gitbash里面再装。 需要输入命令“ git clone –recursive git://github.com/isaacs/npm.git”，然后再输入“cd npm”，“node cli.js install npm -gf” 123git clone --recursive git://github.com/isaacs/npm.gitcd npmnode cli.js install npm -gf windows git bash npm: command not found 1.3 安装Hexo 先选个文件夹作为博客文件存储。这里我选“D:\source\yaojiaxinpc”。 打开gitbash，cd到这个目录。安装hexo：输入指令“npm install hexo-cli -g ”。 等它下载安装好后，输入指令“hexo init”。当然后面可以加文件夹的名字。不加就默认装在当前目录。 123456789//安装hexonpm install hexo-cli -g//查看hexo版本hexo -v//初始化hexohexo init//会下载文件到当前目录，生成node_modules等文件夹 后期文件夹中的“node_modules”目录，都是从这里的cmd运行编译过去的。 二.初次建站2.1 Hexo建站 这里贴一下npm主页 。上面好东西蛮多，工具类等等。 说明文档：What is npm? 站址文件生成指令： 1hexo g //hexo generate 这时候目录下会多出来一个Public文件夹。里面的东西就是我们需要的网站文件，到时发布到网上的也是这里的东西（不是整个工程，就Public目录下的文件直接上传就行，不然会报错。） 这里我也遇到“hexo Permission denied”的问题，是权限问题，但是由于是运行在windows系统，不是sudo，也不是unsafe和SSH密钥问题。最后解决的方法是：打开gitbash的源文件，cd到新目录重新上面部署的步骤，运行完，快捷方式那个就正常了 2.2 本地站址访问1hexo s //hexo server 2.3 目录结构说明 第一个“node_modules”，都是工具里面的东西，不用关注，当作编译工具看待吧，就是根据“package.json”里面记录的要安装的工具，安装到这个目录底下。 重点关注的是“_config.yml”文件，然后就是“themes”，主题目录，接着是“source”：放博文和图片等等其他东西的地方。 “public”是生成html等最终产物的地方，到时提交这个目录里面的东西上去就行，推荐用GitHub DeskTop，或者SVN提交。厉害的也可以用gitbash。 “scaffolds”目录，就一些模版而已。可以在gitbash里面打： 1hexo new pagename 三.发布Page3.1.1 GitHub准备 这里可以弄SSH密钥后，设置成gitbash来直接“hexo d”就上传public文件目录。也可以手动拖文件到GitHub DeskTop里上传。而拉到网页上的话，github是支持的，但是coding不支持多文件。 注意要先安装插件： npm install hexo-deployer-git –save 下面记录SSH key方式，因为这种方式可以直接gitbash界面操作，可以在执行完“hexo g”后直接“hexo d -m ‘comment message’”就部署上去，很方便。 登陆github个人主页，个人头像下拉–&gt;Settings–&gt;SSH and GPG keys–&gt;New SSH key 然后回到电脑上，生成key文件： 1ssh-keygen -t rsa -C "git邮箱" 连续3次回车就行，就会生成key文件。在系统当前用户目录下(开启查看隐藏文件) %homepath%.ssh 将id_rsa.pub文件以文本方式打开。打开之后全部复制到key中。 然后就可以回gitbash测试情况： 123ssh -T git@github.comyes 12git config --global user.name "git用户名"git config --global user.email "git邮箱" 还没结束，还需要到“_config.yml”文件进行对应的配置： 记住，这里使用的是SSH，所以repository也应该用SSH目录下的。 在github desktop中，这里才是用https下的地址。两个使用的是不同的协议的。 同时注意是主线master。 3.1.2 GitPage访问 到浏览器中输入YaojiaxinPC.github.io (用户名.github.io)。就可以看了。 这里也记录一下gitpage的一些细节吧。 刚注册好后，点击头像左边的“+”，新建目录“New repository”。根据gitpage推荐，是“用户名”+github.io，当然也可以起其他名字，只是起其他名字的话，就变成三级域名了，前缀会自动给你加“用户名.github.io”，后面的才是“/”+你这里起的名字。 在这个页面往下拉，到图中这里，就是设置你的page是关联哪个代码库的，所以是可以更改的。第一次弄的时候，可以到这里选Theme，然后根据步骤自动生成一个页面来试试看效果。 再往下的，就是删库功能项了。 剩下的，就是一点点修改，本地看效果后，更新上来看外网效果了。 3.2.1 Coding准备 这里也讲讲国内的coding吧。 和github差距还是蛮大的，不过好在国内访问快。现在和TX联手了，收费项目也变多了。商业用途用它还不错，但是个人非盈利的就不好说了。不过还是多多支持国产吧。这里还是得感谢coding的，gitpage那边，整优化搞了两三天，都不理想，访问最快2s起步（还是半夜3、4点的才能达到这个效果），后面还是挂到coding这边，就能秒开了。 3.2.2 Coding Pages访问 coding做得比gitpage好的地方还是有的，在dns转址上，极其方便，还加了https访问。这点得给个赞。 这里的设置和gitpage的是一样的，不过更好操作一些。而且还没项目名字限制，想起什么名字都行。 四.Hexo更换Themes 到这里，其实已经可以自己做博客放上去了。不过，作为一个非前端人员，而我又觉得初始版面不好看，怎么处理？幸好hexo早考虑到这个，给了好多皮肤让我们换。 Hexo主题官网 更换Next主题 我比较喜欢头像挂左边的，加上搜索教程的时候，都是推荐yilia 的。所以一开始是用的这个主题。 12hexo clean //删除public目录（建议每次生成都要执行该删除指令，防止冲突）git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 这里的操作，其实就是去github上拷贝一个皮肤下来，放到目录“themes/yilia”。所以其实你也可以手动去网页上下载zip，然后解压到themes目录下就行。 下载好themes后，修改主配置文件： 该部分另外开一个文章详细说明。 结尾贴一下几篇Markdown的介绍网址吧。 当然还有个中文前面隔开两个空格的小窍门：英文输入法下，切全角，然后两下空格。 Cmd Markdown 编辑阅读器 MaHua 在线markdown编辑器 Markdown 基本语法 Markdown 语法整理大集合2017]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客心得---godaddy+WordPress]]></title>
    <url>%2F6CreatWordPress%2F</url>
    <content type="text"><![CDATA[本文是记录如何搭建个人博客系列的第一篇。该系列有3篇：1.付费虚拟云主机+WordPress；2.免费github+Hexo；3.个人站点yaojx.net的优化之路。 搭建个人博客的第一篇，理应分析一下为什么要弄这件事。 作为一个CS开发人员，现在转型手游/端游开发，和网站开发还是没挂钩，怎么会想到做一个网站？其实，不应该是前端开发人员才做网站，谁都可以做，只是使用的工具不同而已：从事网站开发的，一般都是自己搭整套系统来显示自己的实力；非网页开发的程序员，靠搜索+工具，也是能搭出来一个网站的；再特殊点，非技术人员，花点钱，想弄怎样的网站就能弄怎样的网站。这样实现过程并不是重点，重点是为什么要做网站？ 写代码有好几年了，但是，现在回头发现什么都没留下。为什么会这样？因为平时，虽然经常逛技术论坛和技术博客，但是也是看过后，觉得好的，就收藏网址，几年下来还真保存了几兆的网站链接，下载了不少工程。但是收藏得越多，去回顾的动力就越弱，如果加上这个技术点使用得少，时间一久就会模糊的，导致后面遇到，头脑有个印象，但是就是想不起来。特别是在一次硬盘出问题后就没后文了。 后面接触了GitHub，明白了一个道理：技术无国界，技术需要让人知道。技术应该是分享出来让更多人了解的，大家一起探讨，才能优化改善。GitHub的开源，实际上是他们分享给我们，他们是怎么做到这样的。如果有人能看得懂，并且加入优化改善，一方面对开源方是利好，另一方面，对贡献方，是磨练，也是一种承认，承认你的技术，你对该系统的贡献。久而久之，大家都会一起进步，同时带动更大的群体，发展到现在科技圈的繁荣，越来越多高新技术人才出现。 而如果我还是像之前那样，学到一点东西就悄悄保存在自己的硬盘上，有什么用？这就和你到github上下载东西，用到自己的工程中，却把水印去掉，甚至偷偷改了变量名一样。这并不是你学到东西的体现，只是你会运用的表现。这样并不能进步，永远只能偷偷跟在别人后面。 真正学到东西，是你摸清楚整个流程，然后能用自己的话讲出来。所以这个时候弄一个分享记录平台就有好处了。你学了这个东西，分析记录到平台上，别人看到后，会进行点评，指正里面的错误，或者和你一起讨论。这样才是真正的技术精髓。 所以我就建了这个个人博客了。 整个流程蛮折腾的，也花了点钱，不过好在体验过，学到了东西，也值了。 这里建个人博客，有不花钱的：博客园、CSDN等等，甚至微博、FaceBook都可以。如果想逼格高点，就得注册个人域名了。 我这里用了GoDaddy 注册域名，现在GoDaddy和中国合作了，网站也有中文版，但是由于是国外的，国内访问速度一般般，好处就是不用备案。在阿里腾讯那些注册，得备案，然后要花300+大洋去买主机，不然不给办。不过如果有学生优惠，还是可以在国内弄的。 这里贴一下我当时参考的链接 吧。注意“免费的东西才是最贵的”这个道理。 当时我遇到活动价，基础Linux虚拟主机，1＄/m，然后买一年送一个域名，相当于12x7=84￥=一年期限的“域名”+“博客主机”。当然这里的“博客主机”，可定制性不是很高，没有给Linux的root权限，所以不能自己搭整个网页程序放上去，只能用自带现成的程序。而这个现成程序，就是WordPress。可定制性不高，虽然可以自己改文件，然后更新到主机，但是由于网速问题，我还是放弃了这个念头。 下面记录一下怎么弄： 买了虚拟主机送域名后，登陆帐号，进到“主机管理”页面。目前，这个管理网页，我们用到的操作就是登陆cPanel，还有设置DNS转址（不过响应很慢，改了后等很久才响应过来，建议使用其他的服务商来处理。第三篇博文将介绍这个DNS转址处理）。其他的都不用用到（包括SSH登陆，买包月wordpress套餐等等）。点击“cPanel管理员”登陆。 跳转到“应用程序”–&gt;“My Applications”，可以看到这里已经有一个wordpress，不用理会，直接删除掉。删除要选上面那一排，下面一排的设计不合理，是批量的情况下使用的。 删除完，回到“Applications Browser”，里面有很多现成的程序，不过都是国外的，有时间可以自己试试。找到WordPress，安装。这样才能进行自由定制。安装完后要登陆配置wordpress，流程很简单的，只不过网络问题，得等而已。这里就不记录。 这样，虽然看起来是安装程序，但是仔细看一下，我们看得到文件夹的，是可以上传下载的，数据库也是。管理文件有ftp方式，数据库有一个php页面，都是智能化的，不用自己在linux界面打命令（cPanel的作用–可视化操作）。这样，只要我们能忍受0.3kb/s和经常性断流，是可以把整个博客压缩下载下来，同时把数据库爬一份下来，布到本地，就能随便自己改css、js文件等等那些了，改完再传回去。 怎么玩这个wordpress的，我就不详细说了，网上教程好多，这里贴个链接从零起步搭建Wordpress个人博客——Windows 平台篇（上） 按教程，这里会遇到问题： 网页打不开，报“iis运行php网站提示FastCgiModule错误模块”：打开控制面板，打开“启动或关系Windows功能”，选择iis下的“应用程序开发功能”，开启“CGI”即可。 可以自己加几个挂件上去，写写js脚本，还是蛮好玩的。注意写脚本要区分desktop还是phone，我没接触过前端，所以只是简单的使用了窗口大小来判断，不同情况下，某些插件应该区别对待的。例如我引用了蜘蛛网浮动 的特效。里面设置的是对应电脑端：99个浮动点。如果放到手机端，会密集恐惧症，所以这里就得改小了。这里360浏览器，反应wordpress的大小还是比较有趣的，双击时是变成移动端的宽度大小，所以可以粗略用这个来看效果。当然，还是谷歌浏览器写js脚本比较好。其他还有一个时钟挂件，代码是网上找到。js代码很好找，有现成的，实在不行，F12定位，也能看出来是那些代码，然后复制粘贴+修改，凑齐css+js+html就能跑出来效果了。这样抄了几个小特效，发现前端蛮好玩的，就是代码写起来没vs的美观，一直在想怎么会有人写代码不换行的？还有可视化编程，不能改的时候就能看到效果，只能改后，到浏览器刷新才能看到，这样调位置时超级烦（不过后面发现可以在浏览器中的缓存中改，就能实时看到效果，改好后复制回来就行）。总体上，还是推荐多多接触js的，短短的代码量就能实现很强大的功能。 这里也提一下一些心得吧，在挂饰中，是可以添加js代码的，我的两个特效就是这样加进去的，就不用拉文件下来改，然后发回去的。然后就是发布后，是显示成全文的，所以在编写文章时，开头写大概内容后，添加“more标签”，这样显示出来的才是“大概内容”+“继续阅读”。 说实话，这个买买买，然后建站的过程不耗时，真正耗时是DNS问题。 第一天搭好后，第二天访问，发现404，登cPanel那边跳过去也不行。当时想不明白，只能删了重装。单独删wordpress是不行的，还是不能访问，所以问题不在wordpress上。后面重置cPanel就可以了，同时发现，主机IP变了。说明是服务器问题，后面找了相关的文章，了解到是用的人多，服务器承载不过来，就经常出现这个情况。当时改谷歌的dns、换手机热点、联通移动等等都试过没用。证明问题真不是出在我这边，真的是服务端那边的。ping域名ip，会发现基本不通。 确实，一开始ping自己的域名，400+的延迟，然后挂DNSpod（现在和腾讯合作），没用，因为ip是国外的，所以需要用CDN加速。 后面还是用的国外免费的：cloudflare 登陆注册，设置好域名后，隔几个小时候再来ping，延迟只有200+了。 当然，最好也做一下wordpress的优化，就是把插件全部删除，装两个加速的插件上去（有专门对应cloudflare的插件）。这样，虽然不能让第一次打开能快到什么地步，但是第二次打开却是能很快的（使用缓存加速功能）。 这里能挂载，当然也能解除了： 这个虚拟主机+WordPress，性价比不高，访问很慢，还经常性断网。后面我还是转战GitPage。]]></content>
      <categories>
        <category>编程人生</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Json解析C#的四个库]]></title>
    <url>%2F3JsonDeal%2F</url>
    <content type="text"><![CDATA[目前通讯中http是使用最多的，而其中Json基本是首选。大家平时解析时都是直接调用dll，但是有没有考虑过dll里面怎么处理？这个dll又从哪里来？本文将分享我接触到的4个解析Json的C#开源库。 目前我用得较多的是Newtonsoft ，后面了解到还有轻量的MiniJSON，SimpleJson以及litjson。 这里MiniJSON最精简，是一个class文件，通过对string进行简单字符串的处理来解析。 然后就是SimpleJson，也是一个class文件，不过代码量超级多，功能相对比较全面。看其他博客对这个评价蛮高的，不过我没使用过，暂不评价。 litjson，就文件多一点，好几个class组成。但是看部分博客提到跨平台上有问题。 由于之前是做windows应用，所以一直使用的是Newtonsoft，代码量远超上面的几个，编译出来的dll也是比他们的要大。所以，比较推荐用Newtonsoft，可定制化高很多，功能和内部考虑的东西也完善。 本文暂不讲怎么使用，只简单介绍怎么去github获取上面几个的源码，以及怎么编译。 提到github，这是一个好东西，好多好的开源项目都在上面。不过国内网速超级慢，使用起来不是很方便。一般情况下，可以不注册账号直接下载项目代码，下载下来是一个zip文件。也可以用VS里面的扩展插件GitHub Extension for Visual Studio，下载安装过程有点久，请耐心等待： 使用起来相对没svn好用(当然，这里是可以用svn来使用的)。 推荐使用客户端：GitHubDesktop 下载下来的应该是一个77M的全量包，直接安装就可以使用： 这里使用到的就是File–&gt;Clone…；打开后 这里的url，就是网页上获取的： 这里贴一下看到的其他博主写的专门介绍GitHub Desktop的：Windows 上 GitHub Desktop 的操作 一.MiniJSON github地址：MiniJSON 直接在你的项目中新建一个class，全选代码后复制过去，就可以使用了。 由于需要vpn，所以这里放一下代码吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547/* * Copyright (c) 2013 Calvin Rien * * Based on the JSON parser by Patrick van Bergen * http://techblog.procurios.nl/k/618/news/view/14605/14863/How-do-I-write-my-own-parser-for-JSON.html * * Simplified it so that it doesn't throw exceptions * and can be used in Unity iPhone with maximum code stripping. * * Permission is hereby granted, free of charge, to any person obtaining * a copy of this software and associated documentation files (the * "Software"), to deal in the Software without restriction, including * without limitation the rights to use, copy, modify, merge, publish, * distribute, sublicense, and/or sell copies of the Software, and to * permit persons to whom the Software is furnished to do so, subject to * the following conditions: * * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */using System;using System.Collections;using System.Collections.Generic;using System.IO;using System.Text; namespace MiniJSON &#123; // Example usage: // // using UnityEngine; // using System.Collections; // using System.Collections.Generic; // using MiniJSON; // // public class MiniJSONTest : MonoBehaviour &#123; // void Start () &#123; // var jsonString = "&#123; \"array\": [1.44,2,3], " + // "\"object\": &#123;\"key1\":\"value1\", \"key2\":256&#125;, " + // "\"string\": \"The quick brown fox \\\"jumps\\\" over the lazy dog \", " + // "\"unicode\": \"\\u3041 Men\u00fa sesi\u00f3n\", " + // "\"int\": 65536, " + // "\"float\": 3.1415926, " + // "\"bool\": true, " + // "\"null\": null &#125;"; // // var dict = Json.Deserialize(jsonString) as Dictionary&lt;string,object&gt;; // // Debug.Log("deserialized: " + dict.GetType()); // Debug.Log("dict['array'][0]: " + ((List&lt;object&gt;) dict["array"])[0]); // Debug.Log("dict['string']: " + (string) dict["string"]); // Debug.Log("dict['float']: " + (double) dict["float"]); // floats come out as doubles // Debug.Log("dict['int']: " + (long) dict["int"]); // ints come out as longs // Debug.Log("dict['unicode']: " + (string) dict["unicode"]); // // var str = Json.Serialize(dict); // // Debug.Log("serialized: " + str); // &#125; // &#125; /// &lt;summary&gt; /// This class encodes and decodes JSON strings. /// Spec. details, see http://www.json.org/ /// /// JSON uses Arrays and Objects. These correspond here to the datatypes IList and IDictionary. /// All numbers are parsed to doubles. /// &lt;/summary&gt; public static class Json &#123; /// &lt;summary&gt; /// Parses the string json into a value /// &lt;/summary&gt; /// &lt;param name="json"&gt;A JSON string.&lt;/param&gt; /// &lt;returns&gt;An List&amp;lt;object&amp;gt;, a Dictionary&amp;lt;string, object&amp;gt;, a double, an integer,a string, null, true, or false&lt;/returns&gt; public static object Deserialize(string json) &#123; // save the string for debug information if (json == null) &#123; return null; &#125; return Parser.Parse(json); &#125; sealed class Parser : IDisposable &#123; const string WORD_BREAK = "&#123;&#125;[],:\""; public static bool IsWordBreak(char c) &#123; return Char.IsWhiteSpace(c) || WORD_BREAK.IndexOf(c) != -1; &#125; enum TOKEN &#123; NONE, CURLY_OPEN, CURLY_CLOSE, SQUARED_OPEN, SQUARED_CLOSE, COLON, COMMA, STRING, NUMBER, TRUE, FALSE, NULL &#125;; StringReader json; Parser(string jsonString) &#123; json = new StringReader(jsonString); &#125; public static object Parse(string jsonString) &#123; using (var instance = new Parser(jsonString)) &#123; return instance.ParseValue(); &#125; &#125; public void Dispose() &#123; json.Dispose(); json = null; &#125; Dictionary&lt;string, object&gt; ParseObject() &#123; Dictionary&lt;string, object&gt; table = new Dictionary&lt;string, object&gt;(); // ditch opening brace json.Read(); // &#123; while (true) &#123; switch (NextToken) &#123; case TOKEN.NONE: return null; case TOKEN.COMMA: continue; case TOKEN.CURLY_CLOSE: return table; default: // name string name = ParseString(); if (name == null) &#123; return null; &#125; // : if (NextToken != TOKEN.COLON) &#123; return null; &#125; // ditch the colon json.Read(); // value table[name] = ParseValue(); break; &#125; &#125; &#125; List&lt;object&gt; ParseArray() &#123; List&lt;object&gt; array = new List&lt;object&gt;(); // ditch opening bracket json.Read(); // [ var parsing = true; while (parsing) &#123; TOKEN nextToken = NextToken; switch (nextToken) &#123; case TOKEN.NONE: return null; case TOKEN.COMMA: continue; case TOKEN.SQUARED_CLOSE: parsing = false; break; default: object value = ParseByToken(nextToken); array.Add(value); break; &#125; &#125; return array; &#125; object ParseValue() &#123; TOKEN nextToken = NextToken; return ParseByToken(nextToken); &#125; object ParseByToken(TOKEN token) &#123; switch (token) &#123; case TOKEN.STRING: return ParseString(); case TOKEN.NUMBER: return ParseNumber(); case TOKEN.CURLY_OPEN: return ParseObject(); case TOKEN.SQUARED_OPEN: return ParseArray(); case TOKEN.TRUE: return true; case TOKEN.FALSE: return false; case TOKEN.NULL: return null; default: return null; &#125; &#125; string ParseString() &#123; StringBuilder s = new StringBuilder(); char c; // ditch opening quote json.Read(); bool parsing = true; while (parsing) &#123; if (json.Peek() == -1) &#123; parsing = false; break; &#125; c = NextChar; switch (c) &#123; case '"': parsing = false; break; case '\\': if (json.Peek() == -1) &#123; parsing = false; break; &#125; c = NextChar; switch (c) &#123; case '"': case '\\': case '/': s.Append(c); break; case 'b': s.Append('\b'); break; case 'f': s.Append('\f'); break; case 'n': s.Append('\n'); break; case 'r': s.Append('\r'); break; case 't': s.Append('\t'); break; case 'u': var hex = new char[4]; for (int i=0; i&lt; 4; i++) &#123; hex[i] = NextChar; &#125; s.Append((char) Convert.ToInt32(new string(hex), 16)); break; &#125; break; default: s.Append(c); break; &#125; &#125; return s.ToString(); &#125; object ParseNumber() &#123; string number = NextWord; if (number.IndexOf('.') == -1) &#123; long parsedInt; Int64.TryParse(number, out parsedInt); return parsedInt; &#125; double parsedDouble; Double.TryParse(number, out parsedDouble); return parsedDouble; &#125; void EatWhitespace() &#123; while (Char.IsWhiteSpace(PeekChar)) &#123; json.Read(); if (json.Peek() == -1) &#123; break; &#125; &#125; &#125; char PeekChar &#123; get &#123; return Convert.ToChar(json.Peek()); &#125; &#125; char NextChar &#123; get &#123; return Convert.ToChar(json.Read()); &#125; &#125; string NextWord &#123; get &#123; StringBuilder word = new StringBuilder(); while (!IsWordBreak(PeekChar)) &#123; word.Append(NextChar); if (json.Peek() == -1) &#123; break; &#125; &#125; return word.ToString(); &#125; &#125; TOKEN NextToken &#123; get &#123; EatWhitespace(); if (json.Peek() == -1) &#123; return TOKEN.NONE; &#125; switch (PeekChar) &#123; case '&#123;': return TOKEN.CURLY_OPEN; case '&#125;': json.Read(); return TOKEN.CURLY_CLOSE; case '[': return TOKEN.SQUARED_OPEN; case ']': json.Read(); return TOKEN.SQUARED_CLOSE; case ',': json.Read(); return TOKEN.COMMA; case '"': return TOKEN.STRING; case ':': return TOKEN.COLON; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case '-': return TOKEN.NUMBER; &#125; switch (NextWord) &#123; case "false": return TOKEN.FALSE; case "true": return TOKEN.TRUE; case "null": return TOKEN.NULL; &#125; return TOKEN.NONE; &#125; &#125; &#125; /// &lt;summary&gt; /// Converts a IDictionary / IList object or a simple type (string, int, etc.) into a JSON string /// &lt;/summary&gt; /// &lt;param name="json"&gt;A Dictionary&amp;lt;string, object&amp;gt; / List&amp;lt;object&amp;gt;&lt;/param&gt; /// &lt;returns&gt;A JSON encoded string, or null if object 'json' is not serializable&lt;/returns&gt; public static string Serialize(object obj) &#123; return Serializer.Serialize(obj); &#125; sealed class Serializer &#123; StringBuilder builder; Serializer() &#123; builder = new StringBuilder(); &#125; public static string Serialize(object obj) &#123; var instance = new Serializer(); instance.SerializeValue(obj); return instance.builder.ToString(); &#125; void SerializeValue(object value) &#123; IList asList; IDictionary asDict; string asStr; if (value == null) &#123; builder.Append("null"); &#125; else if ((asStr = value as string) != null) &#123; SerializeString(asStr); &#125; else if (value is bool) &#123; builder.Append((bool) value ? "true" : "false"); &#125; else if ((asList = value as IList) != null) &#123; SerializeArray(asList); &#125; else if ((asDict = value as IDictionary) != null) &#123; SerializeObject(asDict); &#125; else if (value is char) &#123; SerializeString(new string((char) value, 1)); &#125; else &#123; SerializeOther(value); &#125; &#125; void SerializeObject(IDictionary obj) &#123; bool first = true; builder.Append('&#123;'); foreach (object e in obj.Keys) &#123; if (!first) &#123; builder.Append(','); &#125; SerializeString(e.ToString()); builder.Append(':'); SerializeValue(obj[e]); first = false; &#125; builder.Append('&#125;'); &#125; void SerializeArray(IList anArray) &#123; builder.Append('['); bool first = true; foreach (object obj in anArray) &#123; if (!first) &#123; builder.Append(','); &#125; SerializeValue(obj); first = false; &#125; builder.Append(']'); &#125; void SerializeString(string str) &#123; builder.Append('\"'); char[] charArray = str.ToCharArray(); foreach (var c in charArray) &#123; switch (c) &#123; case '"': builder.Append("\\\""); break; case '\\': builder.Append("\\\\"); break; case '\b': builder.Append("\\b"); break; case '\f': builder.Append("\\f"); break; case '\n': builder.Append("\\n"); break; case '\r': builder.Append("\\r"); break; case '\t': builder.Append("\\t"); break; default: int codepoint = Convert.ToInt32(c); if ((codepoint &gt;= 32) &amp;&amp; (codepoint &lt;= 126)) &#123; builder.Append(c); &#125; else &#123; builder.Append("\\u"); builder.Append(codepoint.ToString("x4")); &#125; break; &#125; &#125; builder.Append('\"'); &#125; void SerializeOther(object value) &#123; // NOTE: decimals lose precision during serialization. // They always have, I'm just letting you know. // Previously floats and doubles lost precision too. if (value is float) &#123; builder.Append(((float) value).ToString("R")); &#125; else if (value is int || value is uint || value is long || value is sbyte || value is byte || value is short || value is ushort || value is ulong) &#123; builder.Append(value); &#125; else if (value is double || value is decimal) &#123; builder.Append(Convert.ToDouble(value).ToString("R")); &#125; else &#123; SerializeString(value.ToString()); &#125; &#125; &#125; &#125;&#125; 二.SimpleJson github地址：SimpleJson 你可以下载下来然后用vs打开选Net2.0编译出来一个dll（这里可能会报错，将文件EscapeToJavascriptStringTests去掉就正常了）。但是你也可以像前面那样，新建一个class，然后复制SimpleJson.cs的代码，点击SimpleJson.cs后会进到下面的详情网页，选择图中的Raw，就能进到代码页面，然后Ctrl+A进行全选复制。 三.LitJSON github地址：LitJSON 这个生成超级烦，要搭.net core的环境。由于没接触core开发，后面我还是修改vs工程文件，去掉core后才能生成。 （后面发现，其实这里是因为VS的版本问题，要新版本。这里有篇文章就是问这个的：msbuild-of-vs2017-cannot-compile-net-standard-2-0-project 查官网，只提到装2017，但是明明我的是2017（但是是16年底下载的，Core2.0是17年底出的），.NET Core 2.0.0 SDK这个也安装了，就是无法编译，其实是msbuild 版本。这个问题，和VS2010的msbuild编译不了2015版本的项目是一样的。所以如果装了新版本的，这里不用修改，是可以直接编译的。） 这里也贴一下主页：LitJSON 以及一个老版本的直接dll下载地址：DownloadDll 推荐直接下载github的然后自己编译，因为后面有更新，而网上那些，好多都是好几年前的版本。 下面记录一下我怎么编译的： 实际是修改vs工程文件，然后直接用vs打开就可以编译的，不过这里我也记录一下他自带的那些工具是怎么配置到可以用的。 先记录怎么修改vs工程文件，目录中，实际只要用到\litjson-develop\src\LitJson里的东西： 用记事本打开，ctrl+f查找包含“netstandard”的字段，就是下面截图红色部分，删掉： 这里简单说明一下为什么要删掉： “netstandard”部分是core环境的，目前我没搭这个环境，所以直接编译是会报错的。 而中间的那个，是检查git的，如果你是部署了git，登陆了帐号，就没影响，可以更新并编译，不然就会报错。 删掉上面红色部分后，用vs打开，直接编译就成功了。 接下来介绍怎么修改自带的那些工具来生成，过程繁琐，不过不用修改vs工程文件： 首先运行build.ps1，记住不是sh（这个是linux的），右键–&gt;使用PowerShell运行： 出现下面这样的窗口，实际是里面代码，分析出你要安装这个环境的这个包，正常情况是一直下载不下来的，vpn也救不了，后面挂百度云离线 （ 提取码：0osd）总算下载下来了。 现在目录中多了一个文件夹，里面是安装core的环境的，可以安装，目前我系统是win10版： 这里也简单记一下怎么修改代码让dotnet-install.ps1文件能运行： 首先右键–&gt;编辑；里面好多脚本代码，和C#超级像，有兴趣可以去了解： 这里意思是传一个下载链接给它，然后下载解压（上面一堆脚本都是下载函数）。而现在这个url，是下不下来的，不过我们可以通过IIS，进行localhost下载： windows启用IIS，在程序与功能–&gt;启用或关闭windows功能，然后你看到有iis的就打勾就行了。 然后找到上面图中这个，点击“浏览”，把刚才通过百度云下载的dotnet-sdk-2.1.4-win-x64.zip复制过去，当然还有复制dotnet-install.ps1这个文件，不过.ps1这个后缀，在iis里面不能访问，所以我修改成txt，反正脚本中只是找文件下载，下载后保存的命名是自己定的。 然后就是修改脚本： 修改build.ps1，告诉它去localhost目录下载这个txt；同时修改这个txt去localhost下载这个zip。 这样就能正常运行了，但是这里由于网络原因，还会报错，就安装cake部分，不过可以重新启动就行，cake的下载和安装过程较顺利，安装好后多了3个文件夹： 一个是检查git的，一个是编译工具cake。 所以如果想用这个工具编译，最好是登陆git的，这样就能用自带工具编译了，core也能编译： 这里我删了core的环境安装部分，然后直接运行build.ps1就可以了。 这种方式就不用修改vs工程文件。 从ps1文件里面了解到，是调用cake来编译的，所以，其实我们可以直接cmd来操作： cmd到build.cake所在目录，然后调用cake.exe。 四.Newtonsoft.Json 主页：www.newtonsoft.com github地址：Newtonsoft.Json 这个就编译比较简单，但是会报错readonly struct（去掉readonly就行），用vs编辑工程文件，像前面那个一样删掉core和phone等等那些选项，然后再编译就能编译通过。自带的脚本也是，下载部分很顺利就能下载，155m左右；但是还有附加的编译环境，也是core的。 这里这个错，其实是C# 7的特性，老版本的vs都不支持。然后core的问题，其实也是更新新版本vs就能解决，后面我更新了新版本后，msbuild版本上来了，就能正常编译了。为什么在第三个那里没注意到时msbuild，因为那里用的是cake，所以当时是能用脚本编译，但是不能vs编译，后面找多点资料后才想起是这个可能。所以这里我就直接更新vs，然后就能直接编译了。什么都不用改。 这里放一下vs2017最新版的安装索引包吧： 两个官网下载地址： 地址1：vs2017-relnotes#15.1.26430.06 地址2：visualstudio.microsoft.com 以及.NET downloads：.NET 附加一下百度云，就是本篇文章用到的配置环境所要下载的东西（要vpn的那几个）： 链接 提取码：1t2x 这里有个文章提到这个新特性：C# 7 Series, Part 6: Read-only structs 以及两篇介绍的： .NET Core 2.0及.NET Standard 2.0 NET Standard/Core中配置使用TargetFrameworks输出多版本类库及测试： 平时用这个库比较多的原因，就是可定制化高，可以设置null值要不要序列化 ，等等之类的定制。 结尾附几个博主写的库分享： 序列化效率比拼——谁是最后的赢家Newtonsoft.Json 几个常用Json组件的性能测试]]></content>
      <categories>
        <category>开源库分享</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# Obsolete、Contional等等一些特性的介绍]]></title>
    <url>%2F4fivefeatures%2F</url>
    <content type="text"><![CDATA[本文分享一些代码使用Attribute的高级写法部分，日常使用中应该很少用到，但是是能给代码书写带来很好的优化效果的。 这些东西其实和xml解析时定义的class中做的标记、自定义配置文件的class标记、枚举中文标记等等是类似的。都是在上面“[]”+标记。 日常编码中，应该Enum的中文标记是使用最多的，接下来就是xml解析，自定义配置文件应该用的人比较少，毕竟实用性不大，直接定义字段，或者使用系统自带的要容易用一些。接下来分享的几个，应该较少人接触过。 一.Obsolete 类似tooltip提示，一般写接口的人会用到，用于标记函数是否过时，以及强制让函数无法通过编译。 12345678910111213141516171819public static class TestObsolete&#123; [Obsolete("OldMethod,please use NewMethod", false)] public static void OldMethod() &#123; Console.WriteLine("Old Method"); &#125; [Obsolete("Error Method,you can't use this method!", true)] public static void ErrorMethod() &#123; Console.WriteLine("Error Method"); &#125; public static void NewMethod() &#123; Console.WriteLine("New Method"); &#125;&#125; 实例中的三个方法是一样的操作：调用输出信息。照理说，是能直接调用然后输出的，毕竟没有语法错误，编译器也没提示函数有问题。 但实际使用时是：一个警告，一个直接错误。 直接给你一个error，不让编译通过。 查看定义，该属性是继承Attribute，这样用法就是直接标在函数或者成员上面，并用“[]”包起来。该特性有三种构造函数，第二种常用，就是让函数提示过时，同时里面有message提示信息。用法就是上面第一张图那样，让函数本身“过时”，给了一个警告提，同时鼠标移上去时，会提示message的信息。第三种构造函数，就是加了error，标记是显示成“警告”（可以编译通过），还是“错误”（无法编译通过）。 这个特性，一般写接口的人会使用到，在接口的版本更新后，如果替换了新接口，但是又想老程序能使用时，一般保留老接口的代码。不过这里就有问题了，接下来新使用的程序，应该让他们用新接口而不是用老接口：如果说写在文档里面说明这个情况，但是好多人是连接口文档都不看的，直接dll引用就开始写代码的；如果写在注释里面？那更加不行，一般没报错，是很少有人去看注释的。所以这时候就得用特性了，使用这个特性，写代码的时候就直接编译器提示了，使用者全部都会看到这个提示。（unity经常用这个特性提示每次更新版本后丢弃的老属性，不过现在国内绝大部分公司，都是直接删掉老函数，然后拉分支来处理的，这样导致后期一大堆分支，维护很麻烦） 二.Conditional 一个好玩的特性，类似于 #if XXXX #elif XXXX #else XXX #endif 这种使用： 使用方式如下： 1234567891011121314using System;using System.Diagnostics;namespace FeaturesDemo&#123; public class TestConditional &#123; [Conditional("ConsoleOut")] public static void ConsoleOut(string message) &#123; Console.WriteLine(message); &#125; &#125;&#125; 调用时：发现明明代码写在那里，但是却不执行： 因为它的使用前提是你要提示它“要执行”，它才会执行。不然没提示，代码在，但是不执行。 怎么提示： 方法一：在开头写#define +构造函数中传递的字符串 方法二：使用“条件编译符号” 这里插播一下怎么运行core程序，因为vs编译生成的是dll： cd到vs工程文件所在地方，然后“dotnet build”或者“dotnet run”都行，run是编译后同时运行，然后cd到dll所在地方，“dotnet”+项目名，就能运行。当然目录下要有“项目名.runtimeconfig.json”这个文件（标记目标环境） 这里分享几个参考的博文： .NET Core全面扫盲贴 .NET Core - .NET 使用 .NET Core 跨平台运行 .NET Core 跨平台执行命令、脚本 三.CallXXXX特性 这个东西实用性一般般，用于调试排错的时候，就是你找到在哪里出错了，但是看代码又不知道上一层是哪个函数（就是哪里调用这个函数导致出问题），就加这个特性，一层一层排上去，就能找到是哪里出问题了。 之前不知道有这个特性的时候，我都是直接用反射，找到哪个函数调用，然后一层一层反射上去。反射的过程超级麻烦，实用性也不好。当然，如果可以，建议直接用vs远程附加调试，打断点就能知道到底怎么出问题了。 四.DebuggerStepThrough 好吧，这个算凑数的。 这个特性是调试的时候，F10和F11的区别，就是如果函数加了这个特性，执行到这个函数，就算你使用F11（单步，逐语句），它也给你当F10（整个函数直接过，逐过程）。 “[System.Diagnostics.DebuggerStepThrough]” 123456789101112131415161718192021using System;using System.Runtime.CompilerServices;namespace FeaturesDemo&#123; public static class TestCall &#123; [System.Diagnostics.DebuggerStepThrough] public static void CallMethod(string message, [CallerFilePath] string filepath = "", [CallerLineNumber]int linenumber = 0, [CallerMemberName]string membername = "") &#123; Console.WriteLine(message); if (!string.IsNullOrEmpty(filepath)) Console.WriteLine("filepath:" + filepath); if (!linenumber.Equals(0)) Console.WriteLine("linenumber:" + linenumber); if (!string.IsNullOrEmpty(membername)) Console.WriteLine("membername:" + membername); &#125; &#125;&#125; 五.枚举中文Description Description，这个最常用。 123456789101112131415161718192021222324252627282930using System;using System.ComponentModel;using System.Reflection;namespace FeaturesDemo&#123; public static class EnumCN &#123; public static string GetDescription(Enum obj) &#123; FieldInfo fi = obj.GetType().GetField(obj.ToString()); DescriptionAttribute[] arrDesc = fi.GetCustomAttributes(typeof(DescriptionAttribute), false) as DescriptionAttribute[]; if (arrDesc != null &amp;&amp; arrDesc.Length &gt; 0) return arrDesc[0].Description; else return null; &#125; &#125; public enum PersonSex &#123; [Description("男人")] Man = 0, [Description("女人")] Woman = 1, [Description("人妖")] OtherSex = 2 &#125;&#125; 这里就不多解释了。做界面的人建议多用，在一些选项框中，中文对应枚举，比对应源的第几个要好用，也不容易出问题。 这里插播一下enum的另一个用法：权限校验 就是把枚举和二进制关联起来，0表示没这个权限，1表示有，然后进行与或非操作就能判断。 定义枚举：1234567891011121314[Flags]public enum EnumPower&#123; [Description("游客")] AllNull = 0, //0x00 表示全部没有 0000 [Description("创建")] Create = 1 &lt;&lt; 0, //0x01或者1 2的0次方 0001 [Description("读取")] Read = 1 &lt;&lt; 1, //0x02或者2 2的1次方 0010 [Description("更新")] Update = 1 &lt;&lt; 2, //0x04或者4 2的2次方 0100 [Description("删除")] Delete = 1 &lt;&lt; 3 //0x08或者8 2的3次方 1000&#125; 接下来，把权限“与”/“或”操作起来，然后检查是否某位上为1就是有该权限。使用该用法，数据库保存用户权限就容易了，例如有read和delete权限的，直接0010|1000=1010。 判断是否有read权限时：1010&amp;0010 = 0010-&gt;1表示有；当没有时：1000&amp;0010=0000-&gt;0 判断是否有read或者delete其中之一：1010&amp;(0010|1000)=1010-&gt;都有。或者其中一个有0010&amp;(0010|1000)=0010。 可以发现，判断权限时，我们只要&amp;|操作后，检查==0？就可以了。省了一堆if else if语句。 可以合并成一个函数： 123456789101112131415161718192021222324252627282930313233343536public static class CheckPower&#123; /// &lt;summary&gt; /// 检查是否有权限， /// |操作会合并成一个值，表示满足之一就返回true /// 如果有多个值，表示需要满足全部值才返回true /// &lt;/summary&gt; /// &lt;param name="ower"&gt;用户的权限值&lt;/param&gt; /// &lt;param name="powers"&gt;要检查的权限值&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool CheckHasPower(EnumPower owner, params EnumPower[] powers) &#123; //没有传权限过来，直接返回false if (powers == null || powers.Length &lt; 1) return false; //只传一个权限(单权限，或者几个权限的|操作) if (powers.Length &lt;= 1) &#123; //如果是EnumPower.AllNull，直接比较是否和owner一样 if (powers[0].Equals(EnumPower.AllNull)) return owner.Equals(powers[0]); else return (owner &amp; powers[0]) != 0x00; &#125; //合并要检查的权限值 foreach (var item in powers) &#123; //核对每一项，如果有一项不成立，返回false if ((owner &amp; item) == 0x00) return false; &#125; return true; &#125;&#125; 使用： 1234567891011121314151617181920 EnumPower owner = EnumPower.AllNull; owner = EnumPower.Delete | EnumPower.Create; Console.WriteLine(owner); Console.WriteLine("EnumPower.Delete:" + CheckPower.CheckHasPower(owner, EnumPower.Delete) + System.Environment.NewLine); Console.WriteLine("EnumPower.Read:" + CheckPower.CheckHasPower(owner, EnumPower.Read) + System.Environment.NewLine); Console.WriteLine("EnumPower.AllNull:" + CheckPower.CheckHasPower(owner, EnumPower.AllNull) + System.Environment.NewLine); Console.WriteLine("EnumPower.Delete | EnumPower.Update:" + CheckPower.CheckHasPower(owner, EnumPower.Delete | EnumPower.Update) + System.Environment.NewLine); Console.WriteLine("EnumPower.AllNull | EnumPower.Update:" + CheckPower.CheckHasPower(owner, EnumPower.AllNull | EnumPower.Update) + System.Environment.NewLine); Console.WriteLine("EnumPower.Update | EnumPower.Delete:" + CheckPower.CheckHasPower(owner, EnumPower.Update | EnumPower.Delete) + System.Environment.NewLine); Console.WriteLine("EnumPower.Update &amp;EnumPower.Delete:" + CheckPower.CheckHasPower(owner, EnumPower.Update, EnumPower.Delete) + System.Environment.NewLine); Console.WriteLine("EnumPower.Read | EnumPower.Update | EnumPower.Create | EnumPower.Delete:" + CheckPower.CheckHasPower(owner, EnumPower.Read | EnumPower.Update | EnumPower.Create | EnumPower.Delete) + System.Environment.NewLine); int enumlength = Enum.GetNames(typeof(EnumPower)).Length - 1;//0开始，所以要-1 //等价于前面全部|的操作 Console.WriteLine(((EnumPower)(1 &lt;&lt; enumlength) - 1) + ":" + CheckPower.CheckHasPower(owner, ((EnumPower)(1 &lt;&lt; enumlength) - 1)) + System.Environment.NewLine);Console.WriteLine("EnumPower.Read &amp;EnumPower.Update &amp;EnumPower.Create &amp;EnumPower.Delete:" + CheckPower.CheckHasPower(owner, EnumPower.Read, EnumPower.Update, EnumPower.Create, EnumPower.Delete)); 这里比较好玩的是“1&lt;&lt;n”，表示2的n次方。注意“|”和“&amp;”的区别就可以使用了，特别注意&amp;操作，前后顺序，有没有加（），结果是不同的。以及拥有全部权限的另类算法，应该是1111（4个1）,即10000（5位）-1. 当然普遍写法是直接|或者&amp;然后判断==0？，就不会写一个函数来增加多余的部分的。所以上面这个函数显得突兀，只是为了直观理解而写的。 六.自定义特性 特性类的后缀要以Attribute结尾，需要继承自System.Attribute，一般情况下声明为sealed。 示例如下：注意使用的时候自动去除Attribute后缀 获取内容的方式： 123456789101112131415161718192021222324252627282930313233public static class TestMyMethod&#123; public static void GetFromClass(TestMyClass t) &#123; Console.WriteLine(t.TestProperty); MyAttribute[] arrDesc = Attribute.GetCustomAttributes(t.GetType(), typeof(MyAttribute)) as MyAttribute[]; if (arrDesc != null) foreach (var item in arrDesc) &#123; Console.WriteLine("Description:" + item.Description); Console.WriteLine("LineNumber:" + item.LineNumber); Console.WriteLine("IsClass:" + item.IsClass); Console.WriteLine(); &#125; &#125; public static void GetFromProperty(TestMyProperty t) &#123; Console.WriteLine(t.TestProperty); foreach (System.Reflection.PropertyInfo item in t.GetType().GetProperties()) &#123; MyAttribute[] atts = Attribute.GetCustomAttributes(item, typeof(MyAttribute)) as MyAttribute[]; if (atts == null) continue; foreach (var at in atts) &#123; Console.WriteLine("Description:" + at.Description); Console.WriteLine("LineNumber:" + at.LineNumber); Console.WriteLine("IsClass:" + at.IsClass); Console.WriteLine(); &#125; &#125; &#125;&#125; 注意当特性放在不同的地方时获取方式不同，类中的字段是class.GetProperties()下的内容，然后才可以 Attribute.GetCustomAttributes 注意当命名不规范的时候，是不会自动裁剪后缀的： 当然还有C++和其他dll导入时的特性，xml编辑的特性，以及ORM特性等等，由于那些的主题应该是对应的内容，特性只是一个小小的标记，所以那部分的内容到时放在具体项目中分享。 本文测试程序工程可以从git直接获取： git代码库: Codes]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Attribute特性</tag>
        <tag>enum特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包Closure]]></title>
    <url>%2F5Closure%2F</url>
    <content type="text"><![CDATA[本文记录在编程中遇到的一个疑难杂症，for循环中的异步赋值结果和理想情况对不上：全部赋值成同一个值。 先贴代码： 1234567for (int i = 0; i &lt; 10; i++)&#123; System.Threading.ThreadPool.QueueUserWorkItem((o) =&gt; &#123; Console.WriteLine(i); &#125;);&#125; 上面这段代码，照理是进行异步处理，开了线程池来打印。理想输出是0~10这样。 但结果： 这里就是闭包现象。 闭包： 内层的函数可以引用包含在它外层的函数的变量，即使外层函数的执行已经终止。但该变量提供的值并非变量创建时的值，而是在父函数范围内的最终值。 这里有篇博文也介绍这个，上面的概念 是复制该博文过来的。 这里简单理解，就是变量i，在lamdb表达式的时候，传的是地址，而实际上，这个地址上的值已经执行完for变成10了（理想情况下，传的应该是值0~9）。 照这样理解，可以搞一个中间缓冲值（即每次传的都不是同一个地址）来处理：（输出没按照顺序，是因为多核处理问题，这里不进行讨论） 明显已经没有重复值了，但是记住，地址！就是说tmp的声明必须在for内，如果放到外面（或者放在线程池里面）： 神秘现象，直接是9，不是10了？？？好吧，不小心给自己挖了个坑，接下来开始填坑吧。分析为什么是9，不是10： 循环中确实是0~9，但是最后i++变成10，进行i&lt;10的判断后false，不进入循环了，所以i最后结果为10，tmp=9. 坑解决。 但这里又有新坑，按前面的理解，不是全部应该“in :9___10”，怎么还出现”in :6___6”的？ 其实是因为console占用了时间，导致线程池的在for还未执行完的时候就开始了（线程池创建后还得等待分配资源才能启动，所以有延迟），所以就可以看到，前面数字很乱（for还在执行，所以数字还在变），到后面才变成全部9（for执行完毕）。 这里有多线程的知识，这里暂时不讨论，简单讲，如string类型的，因为是每个线程会复制一份到自己环境中操作，修改完毕后才通知回主地址，如果这时出现A、B线程同时拷贝了数据去操作，又同时通知回来，就导致脏数据产生（互相覆盖），所以就得用多线程锁（实质是内存片段锁的处理，锁住主地址的访问，不允许拷贝处理，只能排队，变成类似单线程操作）来处理。 下面贴一下内存地址部分测试的demo，证明用的是同一个地址： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class test&#123; //地址不变 public int num; //string的内容变时，实际是重新占用内存，然后存入新值，所以只要内容发生变化，内存肯定变 public string str; public void MethodA() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.Threading.ThreadPool.QueueUserWorkItem((o) =&gt; &#123; num = i; str = i.ToString(); GetAddr(); &#125;); &#125; &#125; public void MethodB() &#123; for (int i = 0; i &lt; 10; i++) &#123; //System.Threading.ThreadPool.QueueUserWorkItem((o) =&gt; //&#123; num = i; str = i.ToString(); GetAddr(); //&#125;); &#125; &#125; unsafe void GetAddr() &#123; //这个是类对象，放在堆里面 fixed (int* p = &amp;num) &#123; Console.WriteLine("&#123;0&#125;__:Address of numbe:0x&#123;1:x&#125;", num, (int)p); &#125; //fixed(char* p= str) //&#123; // Console.WriteLine("&#123;0&#125;__:Address of char:0x&#123;1:x&#125;", str, (int)p); //&#125; //GetAddrZ(num); &#125; ////弄成函数传值的话，地址是变化的，因为是一份拷贝 //unsafe void GetAddrZ(int n) //&#123; // //获取栈上变量的地址 // int* p = &amp;n; // Console.WriteLine("&#123;0&#125;__:Address of n:0x&#123;1:x&#125;\n", num, (int)p); //&#125;&#125; 先使用int： 接下来是string： 这里的main函数是： 12345678910static void Main(string[] args)&#123; test t = new test(); t.MethodA(); Console.WriteLine(); Console.WriteLine(); t.MethodB(); Console.ReadLine();&#125; 当然这里也会出现这种情况： 发现这里上面本应该一致的地址，也会出现不同。 重复多次执行经常出现这种情况。 这里就是引用类型在多线程情况下的问题。 这里简单提及“原子操作volatile”： 原子操作 volatile。通知编译器，不允许拷贝，全部访问都是去主地址拿。算是最简单的多线程处理操作，实质这里没使用到加锁，还是会出现问题的： 这里放一下简单的加锁操作： 12345678910111213private object lockstr = new object();private volatile string _str = "";public string Str&#123; get &#123; return _str; &#125; set &#123; lock (lockstr) &#123; _str = value; &#125; &#125;&#125; 多线程内容超级多，等我整理好后再发专门的主题。这里只提初级的加锁方式lock(obj)。 本文测试程序工程可以从git直接获取： git代码库: Codes]]></content>
      <categories>
        <category>编程疑难杂症</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入门级的8种算法记录]]></title>
    <url>%2F2SortMethon%2F</url>
    <content type="text"><![CDATA[本文记录算法中入门级别的8种简单排序算法。 冒泡排序 2. 选择排序 3. 插入排序 4. 堆排序 5. 归并排序 6. 快速排序 7. 希尔排序 8. 基数排序 基础代码实现： 1.抽象公共接口部分1234interface ISortMethod&#123; IList&lt;int&gt; GetResult(IList&lt;int&gt; sourcelist,out int countnum);&#125; 2.建立公共基类进行数据有效性校验和控制台输出的颜色标记12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class SortBaseClass : ISortMethod&#123; public IList&lt;int&gt; GetResult(IList&lt;int&gt; sourcelist, out int countnum) &#123; return CheckEffect(sourcelist,out countnum); &#125; /// &lt;summary&gt; /// 进行数据的有效性判断 /// &lt;/summary&gt; /// &lt;param name="sourcelist"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private IList&lt;int&gt; CheckEffect(IList&lt;int&gt; sourcelist, out int countnum) &#123; IList&lt;int&gt; resultlist = null; countnum = 0; if (sourcelist != null) &#123; if (sourcelist.Count &gt; 0) &#123; resultlist = Sort(sourcelist,out countnum); &#125; else &#123; resultlist = sourcelist; &#125; &#125; return resultlist; &#125; /// &lt;summary&gt; /// 由具体的算法部分进行重写 /// &lt;/summary&gt; /// &lt;param name="sourcelist"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; protected virtual IList&lt;int&gt; Sort(IList&lt;int&gt; sourcelist, out int countnum) &#123; countnum = 0; return sourcelist; &#125; /// &lt;summary&gt; /// 控制台过程输出 /// &lt;/summary&gt; /// &lt;param name="sourcelist"&gt;&lt;/param&gt; /// &lt;param name="n"&gt;交换的前面一个数的序号&lt;/param&gt; /// &lt;param name="m"&gt;交换的后面一个数的序号&lt;/param&gt; protected void ConsoleOutProcess(IList&lt;int&gt; sourcelist,int n,int m) &#123; for (int i = 0; i &lt; sourcelist.Count; i++) &#123; if (i &lt; sourcelist.Count - 1) &#123; if (i == n || i == m) &#123; Console.ForegroundColor = ConsoleColor.Green; &#125; else Console.ForegroundColor = ConsoleColor.White; Console.Write(sourcelist[i]); if (i != n) &#123; Console.ForegroundColor = ConsoleColor.White; Console.Write("--&gt;"); &#125; else &#123; Console.Write("&lt;--"); &#125; &#125; &#125; Console.ForegroundColor = ConsoleColor.White; if (sourcelist.Count - 1 == n || sourcelist.Count - 1 == m) &#123; Console.ForegroundColor = ConsoleColor.Green; &#125; Console.Write(sourcelist[sourcelist.Count - 1]); Console.ForegroundColor = ConsoleColor.White; Console.WriteLine(); &#125;&#125; 3.main函数具体打印代码1234567891011121314151617181920212223242526272829static void Main(string[] args)&#123; List&lt;int&gt; numlst = new List&lt;int&gt;() &#123; 23, 44, 66, 66, 76, 98, 11, 3, 9, 7 &#125;; ISortMethod sort = new BubbleSortMethod(); Console.WriteLine("原数列为："); StringBuilder str = new StringBuilder(); for (int i = 0; i &lt; numlst.Count; i++) &#123; str.Append(numlst[i] + " "); &#125; Console.WriteLine(str.Remove(str.Length - 3, 3).ToString()); Console.WriteLine(System.Environment.NewLine); int countnum = 0; List&lt;int&gt; result = sort.GetResult(numlst,out countnum) as List&lt;int&gt;; Console.WriteLine(System.Environment.NewLine); Console.WriteLine("经过了&#123;0&#125;次数据对比 ", countnum); Console.WriteLine("排序后为："); str.Clear(); for (int i = 0; i &lt; result.Count; i++) &#123; str.Append(result[i] + "--&gt;"); &#125; Console.WriteLine(str.Remove(str.Length - 3, 3).ToString()); Console.ReadKey();&#125; 4.具体算法实现部分具体实现算法，同时添加过程打印以便分析。 一. 冒泡排序1.1原理 冒泡排序 （Bubble Sort）算法的原理如下: 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 1.2具体代码实现123456789101112131415161718192021222324252627public class BubbleSortMethod : SortBaseClass&#123; protected override IList&lt;int&gt; Sort(IList&lt;int&gt; sourcelist, out int countnum) &#123; IList&lt;int&gt; resultlist = sourcelist; countnum = 0; int temp = int.MinValue; for (int i = 0; i &lt; sourcelist.Count - 1; i++) &#123; //最后一个数最大，所以后面的数不必再次比较 -i for (int j = 0; j &lt; sourcelist.Count - 1 - i; j++) &#123; if (resultlist[j] &gt; resultlist[j + 1]) &#123; temp = resultlist[j + 1]; resultlist[j + 1] = resultlist[j]; resultlist[j] = temp; ConsoleOutProcess(resultlist, j, j + 1); &#125; countnum++; &#125; &#125; return resultlist; &#125;&#125; 同时修改main函数的算法为具体的： ISortMethod sort = new BubbleSortMethod(); 执行结果为： 二.选择排序2.1原理 选择排序 （Selection sort）算法的原理如下： 每一次从待排序的数据元素 中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 2.2具体代码实现1234567891011121314151617181920212223242526272829public class SelectionSortMethod : SortBaseClass&#123; protected override IList&lt;int&gt; Sort(IList&lt;int&gt; sourcelist, out int countnum) &#123; IList&lt;int&gt; resultlist = sourcelist; int temp, pos = 0; countnum = 0; for (int i = 0; i &lt; sourcelist.Count - 1; i++) &#123; pos = i; for (int j = i + 1; j &lt; sourcelist.Count; j++) &#123; if (resultlist[j] &lt; resultlist[pos]) &#123; pos = j; &#125; countnum++; &#125; if (pos == i) continue; temp = resultlist[i]; resultlist[i] = resultlist[pos]; resultlist[pos] = temp; ConsoleOutProcess(resultlist, i, pos); &#125; return resultlist; &#125;&#125; 同时修改main函数的算法为具体的： ISortMethod sort = new SelectionSortMethod(); 执行结果为： 三. 插入排序3.1原理 插入排序 （Insert Sort）算法的原理如下: 插入即表示将一个新的数据插入到一个有序数组中，并继续保持有序。例如有一个长度为N的无序数组，进行N-1次的插入即能完成排序。 第一次，数组第1个数认为是有序的数组，将数组第二个元素插入仅有1个有序的数组中； 第二次，数组前两个元素组成有序的数组，将数组第三个元素插入由两个元素构成的有序数组中….. 第N-1次，数组前N-1个元素组成有序的数组，将数组的第N个元素插入由N-1个元素构成的有序数组中，则完成了整个插入排序。 …. 按序比较直到集合排序完毕。 3.2具体代码实现12345678910111213141516171819202122232425262728293031public class NormalInsertSortMethod : SortBaseClass&#123; protected override IList&lt;int&gt; Sort(IList&lt;int&gt; sourcelist, out int countnum) &#123; IList&lt;int&gt; resultlist = sourcelist; countnum = 0; int key = int.MinValue; int i, j = 0; for (j = 1; j &lt; sourcelist.Count; j++) &#123; key = resultlist[j]; i = j - 1;//将数组往后面退1位 while (i &gt;= 0 &amp;&amp; resultlist[i] &gt; key) &#123; countnum++; resultlist[i + 1] = resultlist[i]; i -= 1; &#125;//过滤两个相同大小的数的左右交换 if (resultlist[i + 1] == key) continue;//插入有序的位置（后面的都比这个数大） resultlist[i + 1] = key; ConsoleOutProcess(resultlist, -1, i + 1); &#125; return resultlist; &#125;&#125; 同时修改main函数的算法为具体的： ISortMethod sort = new NormalInsertSortMethod(); 执行结果为： 四. 堆排序4.1原理 堆排序 （Heap Sort）算法的原理如下: 利用二叉树的特性，将剩余数组中的最大值（或最小值）排到开头处。然后去掉该值（提取到新数组开头数值）再次排序得到最值排去新数组那边开头，依次重复操作就能得到结果。 这里用到的 二叉树的特性 是节点i的左子节点为2i，右子节点为2i+1. 结合集合的话-1。集合(n = i-1)（i&gt;0,集合第一个序号为0，故需要-1）,序号(n)的左子节点为序号(2n+1)，右子节点为序号(2n+2)。 int child = 2 * parentid + 1;就是这里的特性使用。 引用 链接 中这个图比较直观。 在下面的代码中是这样的： 4.2具体代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class HeapSortMethod : SortBaseClass&#123; //从parentid往下面排到length位 private int HeapAdjust(IList&lt;int&gt; sourcelist, int parentid, int length) &#123; int countnum = 0; int temp = sourcelist[parentid]; //左子节点 int child = 2 * parentid + 1; while (child &lt; length) &#123; countnum++; //取 左右 子节点中的较大值 if (child + 1 &lt; length &amp;&amp; sourcelist[child] &lt; sourcelist[child + 1]) child++; //与父节点比较，大于父节点就得交换，否则继续下个循环 if (temp &gt;= sourcelist[child]) break; sourcelist[parentid] = sourcelist[child]; ConsoleOutProcess(sourcelist, parentid, child); parentid = child; child = 2 * parentid + 1; &#125; //检查是否进行过交换，并将缓存中的值赋回去 if (sourcelist[parentid] != temp) &#123; countnum++; sourcelist[parentid] = temp; &#125; ConsoleOutProcess(sourcelist, -1, parentid); return countnum; &#125; private IList&lt;int&gt; HeapSort(IList&lt;int&gt; sourcelist, int top, out int countnum) &#123; IList&lt;int&gt; topNode = new List&lt;int&gt;(); countnum = 0; //第一遍，取出最大值，排到第一个(从倒数第二层左子节点开始排) //i--循环到顶0，排出最大值 for (int i = sourcelist.Count / 2 - 1; i &gt;= 0; i--) &#123; countnum += HeapAdjust(sourcelist, i, sourcelist.Count); &#125; //主要排序过程(从最上面到最下面) for (int i = sourcelist.Count - 1; i &gt; sourcelist.Count - top; i--) &#123; //将第一个与最后一个交换位置（最大值装入末尾） int temp = sourcelist[0]; sourcelist[0] = sourcelist[i]; sourcelist[i] = temp; ConsoleOutProcess(sourcelist, 0, i); Console.WriteLine(); countnum++; //i，最后一个，是当前最大值 //topNode 大根堆 topNode.Add(temp); //将去掉最后一个值的集合重新排 countnum += HeapAdjust(sourcelist, 0, i); &#125; //topNode 大根堆 //sourcelist 小根堆 return sourcelist; &#125; protected override IList&lt;int&gt; Sort(IList&lt;int&gt; sourcelist, out int countnum) &#123; IList&lt;int&gt; resultlist = sourcelist; return HeapSort(sourcelist, sourcelist.Count, out countnum); &#125;&#125; 同时修改main函数的算法为具体的： ISortMethod sort = new HeapSortMethod(); 执行结果为： 五. 归并排序5.1原理 归并排序 （Merge Sort）算法的原理如下: 假设序列共有n个元素，将序列每相邻两个数字进行归并操作（merge)，形成floor(n/2)个序列，排序后每个序列包含两个元素。将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素…重复归并，直到所有元素排序完毕。 引用 链接 中这个图比较直观。 5.2具体代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class MergeSortMethod : SortBaseClass&#123; protected override IList&lt;int&gt; Sort(IList&lt;int&gt; sourcelist, out int countnum) &#123; IList&lt;int&gt; resultlist = sourcelist; countnum = 0; DivSort(resultlist, 0, resultlist.Count - 1, ref countnum); return resultlist; &#125; //对折拆分左右两组 private void DivSort(IList&lt;int&gt; sourcelist, int leftid, int rightid, ref int countnum) &#123; if (leftid &lt; rightid) &#123; int midid = (leftid + rightid) / 2; //前1/2 DivSort(sourcelist, leftid, midid, ref countnum); //后1/2 DivSort(sourcelist, midid + 1, rightid, ref countnum); //比较排序(拆分到最后要进行的比较和合并) Merge(sourcelist, leftid, midid, rightid, ref countnum); &#125; //左右坐标相等，或者左边大于右边(midid + 1)，相当于拆到最后一个，进入下一步Merge &#125; //主要排序操作 private void Merge(IList&lt;int&gt; sourcelist, int leftid, int midid, int rightid, ref int countnum) &#123; IList&lt;int&gt; temp = new List&lt;int&gt;(); int i = leftid; int j = midid + 1; while (i &lt;= midid &amp;&amp; j &lt;= rightid) &#123; countnum++; //取最小值存入缓存 if (sourcelist[i] &lt;= sourcelist[j]) temp.Add(sourcelist[i++]); else temp.Add(sourcelist[j++]); &#125; //两种情况只会存在一种：左(/右)边还有值 //左边 while (j &lt;= rightid) &#123; countnum++; temp.Add(sourcelist[j++]); &#125; //右边 while (i &lt;= midid) &#123; countnum++; temp.Add(sourcelist[i++]); &#125; foreach (var item in temp) &#123; //leftid~midid~rightid区间为已排序，其他部分未排序 if (leftid &gt; rightid) break; sourcelist[leftid++] = item; &#125; ConsoleOutProcess(temp, -1, temp.Count); Console.WriteLine(); &#125;&#125; 同时修改main函数的算法为具体的： ISortMethod sort = new MergeSortMethod(); 执行结果为： 六. 快速排序6.1原理 快速排序 （Quick Sort）算法的原理如下: 假设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面： 设置两个变量i、j，排序开始的时候：i=0，j=N-1； 以第一个数组元素作为关键数据，赋值给key，即key=A[0]； 从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换； 从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换； 重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。 引用 链接 中这个图比较直观。 6.2具体代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class QuickSortMethod : SortBaseClass&#123; protected override IList&lt;int&gt; Sort(IList&lt;int&gt; sourcelist, out int countnum) &#123; IList&lt;int&gt; resultlist = sourcelist; countnum = 0; QuickSort(resultlist, 0, resultlist.Count - 1,ref countnum); return resultlist; &#125; private int SortUnit(IList&lt;int&gt; sourcelist, int leftid, int rightid, ref int countnum) &#123; int key = sourcelist[leftid]; int tempid = leftid; while (leftid &lt; rightid) &#123; while (sourcelist[rightid] &gt;= key &amp;&amp; rightid &gt; leftid) &#123; countnum++; --rightid; &#125; sourcelist[leftid] = sourcelist[rightid]; ConsoleOutProcess(sourcelist, leftid, rightid); while (sourcelist[leftid] &lt;= key &amp;&amp; rightid &gt; leftid) &#123; countnum++; ++leftid; &#125; sourcelist[rightid] = sourcelist[leftid]; ConsoleOutProcess(sourcelist, rightid,leftid); &#125; sourcelist[leftid] = key; ConsoleOutProcess(sourcelist, tempid, leftid); return rightid; &#125; private void QuickSort(IList&lt;int&gt; sourcelist, int leftid, int rightid, ref int countnum) &#123; if (leftid &gt;= rightid) return; int indexid = SortUnit(sourcelist, leftid, rightid, ref countnum); QuickSort(sourcelist, leftid, indexid - 1,ref countnum); QuickSort(sourcelist, indexid + 1, rightid, ref countnum); &#125;&#125; 同时修改main函数的算法为具体的： ISortMethod sort = new QuickSortMethod(); 执行结果为： 七. 希尔排序7.1原理 希尔排序 （Shell’s Sort）算法是直接插入排序算法的一种更高效的改进版本： 假设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面： 先取一个小于n的整数增量（一般取n/2）d1，把数组中下标间隔d1的作为一组进行组内排序；然后取第二个增量d2（d1/2）重复操作，直到增量 = 1。 引用 链接 中这个图比较直观。 7.2具体代码实现1234567891011121314151617181920212223242526272829303132333435public class ShellsSortMethod : SortBaseClass&#123; protected override IList&lt;int&gt; Sort(IList&lt;int&gt; sourcelist, out int countnum) &#123; IList&lt;int&gt; resultlist = sourcelist; countnum = 0; int i, j, flag, tmp, gap = sourcelist.Count; while (gap &gt; 1) &#123; gap = gap / 2; do &#123; flag = 0; for (i = 0; i &lt; sourcelist.Count - gap; i++) &#123; countnum++; j = i + gap; if (sourcelist[i] &gt; sourcelist[j]) &#123; tmp = sourcelist[i]; sourcelist[i] = sourcelist[j]; sourcelist[j] = tmp; flag = 1; ConsoleOutProcess(resultlist, j, i); &#125; &#125; &#125; //最后间隔为1时需要多次微调排序 while (gap == 1 &amp;&amp; flag != 0); &#125; return resultlist; &#125;&#125; 同时修改main函数的算法为具体的： ISortMethod sort = new ShellsSortMethod(); 执行结果为： 八. 基数排序8.1原理 基数排序 （Radix Sort）算法的原理如下： 基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。它是一种稳定的排序算法。多关键字排序中有两种方法：最高位优先法(MSD)和最低位优先法（LSD）。通常用于对数的排序选择的是最低位优先法，即先对最次位关键字进行排序，再对高一位的关键字进行排序，以此类推。 引用 链接 中这个图比较直观。 8.2具体代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class RadixSortMethod : SortBaseClass&#123; protected override IList&lt;int&gt; Sort(IList&lt;int&gt; sourcelist, out int countnum) &#123; countnum = 0; int max = sourcelist[0]; //找到最大的数字 foreach (var item in sourcelist) &#123; if (item &gt; max) max = item; &#125; //分析出有多少位数 int digit = 1; while (max / 10 != 0) &#123; digit++; max /= 10; &#125; for (int i = 0; i &lt; digit; i++) &#123; int[] indexCounter = new int[10]; IList&lt;int&gt; tempList = new List&lt;int&gt;(); foreach (var item in sourcelist) &#123; tempList.Add(0); &#125; //排桶 for(int j =0; j&lt; sourcelist.Count; j++) &#123; int number = (sourcelist[j] % Convert.ToInt32(Math.Pow(10, i + 1))) / Convert.ToInt32(Math.Pow(10, i)); //得出i+1位上的数 indexCounter[number]++; &#125; int[] indexBegin = new int[10]; //统计数量分布,例如3，前面有多少个数，就+1放在第几位 for(int k = 1; k &lt; 10; k++) &#123; indexBegin[k] = indexBegin[k - 1] + indexCounter[k - 1]; &#125; for (int k = 0; k &lt; sourcelist.Count; k++) &#123; int number = (sourcelist[k] % Convert.ToInt32(Math.Pow(10, i + 1))) / Convert.ToInt32(Math.Pow(10, i)); //indexBegin[number]++ 指出该数字该排的序号 tempList[indexBegin[number]++] = sourcelist[k]; &#125; sourcelist = tempList; &#125; return sourcelist; &#125;&#125; 同时修改main函数的算法为具体的： ISortMethod sort = new RadixSortMethod(); 执行结果为： 该算法以空间换时间，不用进行数学上的比较就能进行排序。与前面几种算法有一定的区别。 本文测试程序工程可以从git直接获取： git代码库: Codes]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式_静态构造函数实现和IoDH实现]]></title>
    <url>%2F1IoDHSingleton%2F</url>
    <content type="text"><![CDATA[单例模式，简单字面意思就是整个程序中只进行一次初始化的操作。相对于静态类，单例模式能做到延迟加载，以及类继承。本文记录“静态构造函数下的单例模式”，以及介绍“Initialization Demand Holder(IoDH)”模式实现。该示例使用VS2017以及C#进行编程。 一.前言 单例模式，是编程中使用频率相当高的一种最简单的设计模式。可以简单理解为静态类的设计模式化。为什么会区别于静态类？ 静态类，一般用于“工具类”。在数据库连接等等场景下需要多线程的就不能使用静态类，其他应用于单线程下的操作，如文件读取，一般使用静态类。在软件优化中，第一个问题是初始化：静态类，会在程序启动的时候就会初始化，然后全局生存到进程结束。真有这个必要吗？我们打开程序时，一般先是登陆窗口，如果这个时候，一堆静态工具类也要加载初始化，那不就要等好久，还特占内存。 所以在这个情况下产生了能做到延迟加载的单例模式，当然，它还能进行类继承等等其他解耦操作（不过该部分涉及到其他涉及模式，本文不深入讨论）。 二.代码记录2.1 静态构造函数实现单例模式2.1.1 静态类何时初始化 这里我们直接上代码，根据结果进行记录： 字段x初始化会在构造函数前面先执行。（重点。后面单例模式里面执行代码和想象中不同，考虑是这个原因。） 12345678910111213141516171819202122232425262728293031#if step1 public class SingletonTest &#123; public static string x = EchoAndReturn("A_In type initializer");#if step1needstatic /// &lt;summary&gt; /// 当没有写静态构造函数时，框架会自动生成 /// 导致静态字段的初始化跑到了静态方法调用之前 /// 造成对象的提前初始化 /// &lt;/summary&gt; static SingletonTest() &#123; x = "A_static init"; Console.WriteLine(x); &#125;#endif public SingletonTest() &#123; x = "A_nonstatic init"; Console.WriteLine(x); &#125; public static string EchoAndReturn(string s) &#123; Console.WriteLine(s); return s; &#125; &#125;#endif 对应main函数如下： 12345678910111213141516#if step1 static void Main(string[] args) &#123; Console.WriteLine("Starting Main"); //使用静态类 SingletonTest.EchoAndReturn("Echo!"); Console.WriteLine("After echo"); //取出静态类中的静态成员x string y = SingletonTest.x; if (!string.IsNullOrEmpty(y)) &#123; Console.WriteLine(y); &#125; Console.ReadKey(); &#125;#endif 根据main函数代码，直觉上，应该先输出“Starting Main”，然后输出“Echo!”，最后输出”After echo”和SingletonTest.x。总共4个输出。 但是实际： 1.程序运行–》2.执行main函数–》3.使用到静态SingletonTest–》4.静态字段x的初始化–》5.静态构造函数的初始化–》6.静态函数EchoAndReturn的使用 –》字段x的值由于执行顺序，不是默认赋值的”A_In type initializer”，而是静态构造函数中赋值的“A_static”; 如果这里不加静态构造函数？ 1.程序运行–》2.静态类型的初始化，静态SingletonTest、字段x提前初始化–》3.执行main函数。 这里在文末的博文中提到是： 在类中实现静态构造函数，那beforefieldinit属性就会被precise属性替换，确保静态成员会在类第一次使用之前的那一刻进行初始化。如果不显式实现，静态成员会在类第一次使用之前的任何时间初始化（由CLR智能决定）。 比较得出： 显式静态构造函数使对象在被调用的时候才初始化，避免了static类型在程序启动的时候就提前初始化的问题。有利于程序的快速启动与内存的控制。 2.1.2 简单静态类单例模式实现1234567891011121314151617public class SingletonTest&#123; private static readonly SingletonTest _instance = new SingletonTest(); static SingletonTest() &#123; &#125; private SingletonTest() &#123; &#125; public static SingletonTest Instance &#123; get &#123; return _instance; &#125; &#125;&#125; 将构造函数private； 显式实现static构造函数； 创建私有静态实例_instance并初始化； public开放实例对外访问接口 Instance 属性。 这样避免了静态类型的提前初始化，同时直接在初始化时候赋值的方式也避免了需要加锁的问题。 2.1.3 单例模式执行顺序12345678910111213141516171819202122232425262728293031 #if step21 public class SingletonTest &#123; private static readonly SingletonTest _instance = new SingletonTest(); static SingletonTest() &#123; x = "static init console"; Console.WriteLine(x); &#125; private SingletonTest() &#123; x = "nonstatic init console"; Console.WriteLine(x); &#125; public static SingletonTest Instance &#123; get &#123; Console.WriteLine("Instance"); return _instance; &#125; &#125; //测试静态字段，对执行顺序无影响，实际使用应该为非static，同时操作应该通过XX，不能直接操作本字段 private static string x = "xxxx"; public string XX &#123; get &#123; return x; &#125; private set &#123; x = value; &#125; &#125; &#125;#endif main函数中输出 Console.WriteLine( SingletonTest.Instance.XX); 执行结果： 1.程序启动–》2.遇到类SingletonTest–》3.优先初始化static属性_instance–》4._instance=new SingletonTest()进行实例化–》5.完成static属性的初始化后进行static构造函数的初始化–》6.调用SingletonTest.Instance–》7.获取结果XX得”static init” –》注意这里不是先static init，然后才nonstatic init。因为属性的初始化优先于static构造函数。所以最后的结果是静态构造函数得执行顺序在nonstatic的后面。 2.1.4 继承问题 这里题外话记录一下继承时的表现，进一步展示函数执行顺序： 增加子类型： 12345678910111213public class SingletonTest_inherit : SingletonTest&#123; static SingletonTest_inherit() &#123; x = "B_static"; Console.WriteLine("B_static init"); &#125; public SingletonTest_inherit() &#123; x = "B_nonstatic"; Console.WriteLine("B_nonstatic init"); &#125;&#125; 执行结果： 子对象的静态构造函数没有执行。 如果这里增加实例化？ 1.父类型字段x初始化–》2.父类型static构造函数执行–》3.子类型static构造函数执行–》4.父类型构造函数执行–》5.子类型构造函数执行 –》这里父类型和子类型共用同一个字段x，导致字段x的赋值被子类型重写。 2.2 IoDH实现2.2.1 单例模式实现 推荐单例模式使用该方式。在类内部定义内部类来实现单例模式。 12345678910111213public class SingletonTest&#123; private class InnerCLass &#123; static InnerCLass() &#123; &#125; internal static SingletonTest instance = new SingletonTest(); &#125; private SingletonTest() &#123; &#125; public static SingletonTest Instance &#123; get &#123; return InnerCLass.instance; &#125; &#125;&#125; 2.2.2 单例模式执行顺序123456789101112131415161718192021public class SingletonTest&#123; private class InnerCLass &#123; static InnerCLass() &#123; Console.WriteLine("InnerCLass static"); &#125; internal static SingletonTest instance = new SingletonTest(); &#125; private SingletonTest() &#123; Console.WriteLine("SingletonTest nonstatic"); &#125; public static SingletonTest Instance &#123; get &#123; Console.WriteLine("Instance"); return InnerCLass.instance; &#125; &#125; public string XX = "aaa";&#125; 三.相关参考链接 主要参考博文: https://www.cnblogs.com/rush/archive/2011/10/30/2229565.html 提供继承方面的探讨: https://www.cnblogs.com/jiagoushi/p/3775046.html 对第一个博文进行扩展和实践: https://blog.csdn.net/abc524061/article/details/57086267?utm_source=itdadao&amp;utm_medium=referral 本文测试程序工程可以从git直接获取： git代码库: Codes]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>IoDH</tag>
      </tags>
  </entry>
</search>
