<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="C#,数据结构,算法,"><link rel="alternate" href="/atom.xml" title="Yao's Blog" type="application/atom+xml"><meta name="description" content="本文记录算法中入门级别的8种简单排序算法。  冒泡排序　　2.  选择排序　　3.  插入排序　　4.  堆排序　　5.  归并排序　　6.  快速排序　　7.  希尔排序　　8.  基数排序"><meta name="keywords" content="C#,数据结构,算法"><meta property="og:type" content="article"><meta property="og:title" content="入门级的8种算法记录"><meta property="og:url" content="http://yaojx.net/2018/10/14/2SortMethon/index.html"><meta property="og:site_name" content="Yao&#39;s Blog"><meta property="og:description" content="本文记录算法中入门级别的8种简单排序算法。  冒泡排序　　2.  选择排序　　3.  插入排序　　4.  堆排序　　5.  归并排序　　6.  快速排序　　7.  希尔排序　　8.  基数排序"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://yaojx.net/contentimg/2/1.png"><meta property="og:image" content="http://yaojx.net/contentimg/2/2.png"><meta property="og:image" content="http://yaojx.net/contentimg/2/3.png"><meta property="og:image" content="http://yaojx.net/contentimg/2/4.1.png"><meta property="og:image" content="http://yaojx.net/contentimg/2/4.2.png"><meta property="og:image" content="http://yaojx.net/contentimg/2/4.3.png"><meta property="og:image" content="http://yaojx.net/contentimg/2/5.1.png"><meta property="og:image" content="http://yaojx.net/contentimg/2/5.2.png"><meta property="og:image" content="http://yaojx.net/contentimg/2/6.1.png"><meta property="og:image" content="http://yaojx.net/contentimg/2/6.2.png"><meta property="og:image" content="http://yaojx.net/contentimg/2/7.1.png"><meta property="og:image" content="http://yaojx.net/contentimg/2/7.2.png"><meta property="og:image" content="http://yaojx.net/contentimg/2/8.1.png"><meta property="og:image" content="http://yaojx.net/contentimg/2/8.2.png"><meta property="og:updated_time" content="2018-10-18T02:47:46.207Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="入门级的8种算法记录"><meta name="twitter:description" content="本文记录算法中入门级别的8种简单排序算法。  冒泡排序　　2.  选择排序　　3.  插入排序　　4.  堆排序　　5.  归并排序　　6.  快速排序　　7.  希尔排序　　8.  基数排序"><meta name="twitter:image" content="http://yaojx.net/contentimg/2/1.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yaojx.net/2018/10/14/2SortMethon/"><title>入门级的8种算法记录 | Yao's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Yao's Blog</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Welcome to yao's blog.</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i><br> 分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br> 公益404</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yaojx.net/2018/10/14/2SortMethon/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="姚佳鑫"><meta itemprop="description" content=""><meta itemprop="image" content="/contentimg/headpic.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yao's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">入门级的8种算法记录</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-14T22:55:58+08:00">2018-10-14</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span></span> <span class="post-comments-count"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span><a href="/2018/10/14/2SortMethon/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2018/10/14/2SortMethon/" itemprop="commentCount"></span></a></span> <span id="/2018/10/14/2SortMethon/" class="leancloud_visitors" data-flag-title="入门级的8种算法记录"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数&#58;</span><span class="leancloud-visitors-count"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">3.9k 字</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">18 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　本文记录算法中入门级别的8种简单排序算法。</p><ol><li>冒泡排序　　2. 选择排序　　3. 插入排序　　4. 堆排序<br>　　5. 归并排序　　6. 快速排序　　7. 希尔排序　　8. 基数排序<a id="more"></a><h2 id="基础代码实现："><a href="#基础代码实现：" class="headerlink" title="基础代码实现："></a>基础代码实现：</h2></li></ol><h3 id="1-抽象公共接口部分"><a href="#1-抽象公共接口部分" class="headerlink" title="1.抽象公共接口部分"></a>1.抽象公共接口部分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ISortMethod</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">IList&lt;<span class="keyword">int</span>&gt; <span class="title">GetResult</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist,out <span class="keyword">int</span> countnum)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-建立公共基类进行数据有效性校验和控制台输出的颜色标记"><a href="#2-建立公共基类进行数据有效性校验和控制台输出的颜色标记" class="headerlink" title="2.建立公共基类进行数据有效性校验和控制台输出的颜色标记"></a>2.建立公共基类进行数据有效性校验和控制台输出的颜色标记</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public class SortBaseClass : ISortMethod</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IList&lt;<span class="keyword">int</span>&gt; <span class="title">GetResult</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, out <span class="keyword">int</span> countnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CheckEffect(sourcelist,out countnum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">    <span class="comment">/// 进行数据的有效性判断</span></span><br><span class="line">    <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">    <span class="comment">/// &lt;param name="sourcelist"&gt;&lt;/param&gt;</span></span><br><span class="line">    <span class="comment">/// &lt;returns&gt;&lt;/returns&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IList&lt;<span class="keyword">int</span>&gt; <span class="title">CheckEffect</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, out <span class="keyword">int</span> countnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IList&lt;<span class="keyword">int</span>&gt; resultlist = <span class="keyword">null</span>;</span><br><span class="line">        countnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sourcelist != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sourcelist.Count &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                resultlist = Sort(sourcelist,out countnum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                resultlist = sourcelist;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultlist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">    <span class="comment">/// 由具体的算法部分进行重写</span></span><br><span class="line">    <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">    <span class="comment">/// &lt;param name="sourcelist"&gt;&lt;/param&gt;</span></span><br><span class="line">    <span class="comment">/// &lt;returns&gt;&lt;/returns&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> virtual IList&lt;<span class="keyword">int</span>&gt; <span class="title">Sort</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, out <span class="keyword">int</span> countnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        countnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sourcelist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">    <span class="comment">/// 控制台过程输出</span></span><br><span class="line">    <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">    <span class="comment">/// &lt;param name="sourcelist"&gt;&lt;/param&gt;</span></span><br><span class="line">    <span class="comment">/// &lt;param name="n"&gt;交换的前面一个数的序号&lt;/param&gt;</span></span><br><span class="line">    <span class="comment">/// &lt;param name="m"&gt;交换的后面一个数的序号&lt;/param&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ConsoleOutProcess</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sourcelist.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; sourcelist.Count - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == n || i == m)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.ForegroundColor = ConsoleColor.Green;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Console.ForegroundColor = ConsoleColor.White;</span><br><span class="line"></span><br><span class="line">                Console.Write(sourcelist[i]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i != n)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.ForegroundColor = ConsoleColor.White;</span><br><span class="line">                    Console.Write(<span class="string">"--&gt;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.Write(<span class="string">"&lt;--"</span>);</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.ForegroundColor = ConsoleColor.White;</span><br><span class="line">        <span class="keyword">if</span> (sourcelist.Count - <span class="number">1</span> == n || sourcelist.Count - <span class="number">1</span> == m)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.ForegroundColor = ConsoleColor.Green;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.Write(sourcelist[sourcelist.Count - <span class="number">1</span>]);</span><br><span class="line">        Console.ForegroundColor = ConsoleColor.White;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-main函数具体打印代码"><a href="#3-main函数具体打印代码" class="headerlink" title="3.main函数具体打印代码"></a>3.main函数具体打印代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>&gt; numlst = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;() &#123; <span class="number">23</span>, <span class="number">44</span>, <span class="number">66</span>, <span class="number">66</span>, <span class="number">76</span>, <span class="number">98</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span> &#125;;</span><br><span class="line">    ISortMethod sort = <span class="keyword">new</span> BubbleSortMethod();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">"原数列为："</span>);</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numlst.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str.Append(numlst[i] + <span class="string">"   "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(str.Remove(str.Length - <span class="number">3</span>, <span class="number">3</span>).ToString());</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(System.Environment.NewLine);</span><br><span class="line">    <span class="keyword">int</span> countnum = <span class="number">0</span>;</span><br><span class="line">    List&lt;<span class="keyword">int</span>&gt; result = sort.GetResult(numlst,out countnum) as List&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(System.Environment.NewLine);</span><br><span class="line">    Console.WriteLine(<span class="string">"经过了&#123;0&#125;次数据对比 "</span>, countnum);</span><br><span class="line">    Console.WriteLine(<span class="string">"排序后为："</span>);</span><br><span class="line">    str.Clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str.Append(result[i] + <span class="string">"--&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(str.Remove(str.Length - <span class="number">3</span>, <span class="number">3</span>).ToString());</span><br><span class="line">        </span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-具体算法实现部分"><a href="#4-具体算法实现部分" class="headerlink" title="4.具体算法实现部分"></a>4.具体算法实现部分</h4><p>具体实现算法，同时添加过程打印以便分析。</p><h2 id="一-冒泡排序"><a href="#一-冒泡排序" class="headerlink" title="一. 冒泡排序"></a>一. 冒泡排序</h2><h3 id="1-1原理"><a href="#1-1原理" class="headerlink" title="1.1原理"></a>1.1原理</h3><p> <a href="https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306?fr=aladdin" target="_blank" rel="noopener">冒泡排序</a> （Bubble Sort）算法的原理如下:</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><h3 id="1-2具体代码实现"><a href="#1-2具体代码实现" class="headerlink" title="1.2具体代码实现"></a>1.2具体代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class BubbleSortMethod : SortBaseClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> override IList&lt;<span class="keyword">int</span>&gt; <span class="title">Sort</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, out <span class="keyword">int</span> countnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IList&lt;<span class="keyword">int</span>&gt; resultlist = sourcelist;</span><br><span class="line">        countnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="keyword">int</span>.MinValue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sourcelist.Count - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">   <span class="comment">//最后一个数最大，所以后面的数不必再次比较 -i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sourcelist.Count - <span class="number">1</span> - i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (resultlist[j] &gt; resultlist[j + <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = resultlist[j + <span class="number">1</span>];</span><br><span class="line">                    resultlist[j + <span class="number">1</span>] = resultlist[j];</span><br><span class="line">                    resultlist[j] = temp;</span><br><span class="line"></span><br><span class="line">                    ConsoleOutProcess(resultlist, j, j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                countnum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　同时修改main函数的算法为具体的： ISortMethod sort = new BubbleSortMethod();</p><p>　　执行结果为：</p><p><img src="/contentimg/2/1.png" alt="Result pic 1" title="冒泡排序"></p><h2 id="二-选择排序"><a href="#二-选择排序" class="headerlink" title="二.选择排序"></a>二.选择排序</h2><h3 id="2-1原理"><a href="#2-1原理" class="headerlink" title="2.1原理"></a>2.1原理</h3><p> <a href="https://baike.baidu.com/item/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/9762418?fr=aladdin" target="_blank" rel="noopener">选择排序</a> （Selection sort）算法的原理如下：</p><p>　每一次从待排序的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0" target="_blank" rel="noopener">数据元素</a> 中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p><h3 id="2-2具体代码实现"><a href="#2-2具体代码实现" class="headerlink" title="2.2具体代码实现"></a>2.2具体代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SelectionSortMethod : SortBaseClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> override IList&lt;<span class="keyword">int</span>&gt; <span class="title">Sort</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, out <span class="keyword">int</span> countnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IList&lt;<span class="keyword">int</span>&gt; resultlist = sourcelist;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp, pos = <span class="number">0</span>;</span><br><span class="line">        countnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sourcelist.Count - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; sourcelist.Count; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (resultlist[j] &lt; resultlist[pos])</span><br><span class="line">                &#123;</span><br><span class="line">                    pos = j;</span><br><span class="line">                &#125;</span><br><span class="line">                countnum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pos == i) <span class="keyword">continue</span>;</span><br><span class="line">            temp = resultlist[i];</span><br><span class="line">            resultlist[i] = resultlist[pos];</span><br><span class="line">            resultlist[pos] = temp;</span><br><span class="line">            ConsoleOutProcess(resultlist, i, pos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　同时修改main函数的算法为具体的： ISortMethod sort = new SelectionSortMethod();</p><p>　　执行结果为：</p><p><img src="/contentimg/2/2.png" alt="Result pic 2" title="选择排序"></p><h2 id="三-插入排序"><a href="#三-插入排序" class="headerlink" title="三. 插入排序"></a>三. 插入排序</h2><h3 id="3-1原理"><a href="#3-1原理" class="headerlink" title="3.1原理"></a>3.1原理</h3><p> <a href="https://www.douban.com/note/396407547/" target="_blank" rel="noopener">插入排序</a> （Insert Sort）算法的原理如下:</p><p>　插入即表示将一个新的数据插入到一个有序数组中，并继续保持有序。例如有一个长度为N的无序数组，进行N-1次的插入即能完成排序。<br>　第一次，数组第1个数认为是有序的数组，将数组第二个元素插入仅有1个有序的数组中；<br>　第二次，数组前两个元素组成有序的数组，将数组第三个元素插入由两个元素构成的有序数组中…..<br>　第N-1次，数组前N-1个元素组成有序的数组，将数组的第N个元素插入由N-1个元素构成的有序数组中，则完成了整个插入排序。<br>　….<br>　按序比较直到集合排序完毕。</p><h3 id="3-2具体代码实现"><a href="#3-2具体代码实现" class="headerlink" title="3.2具体代码实现"></a>3.2具体代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class NormalInsertSortMethod : SortBaseClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> override IList&lt;<span class="keyword">int</span>&gt; <span class="title">Sort</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, out <span class="keyword">int</span> countnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IList&lt;<span class="keyword">int</span>&gt; resultlist = sourcelist;</span><br><span class="line">        countnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="keyword">int</span>.MinValue;</span><br><span class="line">        <span class="keyword">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; sourcelist.Count; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            key = resultlist[j];</span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数组往后面退1位</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; resultlist[i] &gt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                countnum++;</span><br><span class="line">                resultlist[i + <span class="number">1</span>] = resultlist[i];</span><br><span class="line">                i -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//过滤两个相同大小的数的左右交换</span></span><br><span class="line">            <span class="keyword">if</span> (resultlist[i + <span class="number">1</span>] == key) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入有序的位置（后面的都比这个数大）</span></span><br><span class="line">            resultlist[i + <span class="number">1</span>] = key;</span><br><span class="line">            ConsoleOutProcess(resultlist, -<span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　同时修改main函数的算法为具体的： ISortMethod sort = new NormalInsertSortMethod();</p><p>　　执行结果为：</p><p><img src="/contentimg/2/3.png" alt="Result pic 3" title="插入排序"></p><h2 id="四-堆排序"><a href="#四-堆排序" class="headerlink" title="四. 堆排序"></a>四. 堆排序</h2><h3 id="4-1原理"><a href="#4-1原理" class="headerlink" title="4.1原理"></a>4.1原理</h3><p> <a href="https://www.cnblogs.com/0zcl/p/6737944.html" target="_blank" rel="noopener">堆排序</a> （Heap Sort）算法的原理如下:</p><p>　利用二叉树的特性，将剩余数组中的最大值（或最小值）排到开头处。然后去掉该值（提取到新数组开头数值）再次排序得到最值排去新数组那边开头，依次重复操作就能得到结果。<br>　这里用到的 <a href="https://www.jianshu.com/p/106fdd9976a8" target="_blank" rel="noopener">二叉树的特性</a> 是节点i的左子节点为2i，右子节点为2i+1.<br>　结合集合的话-1。集合(n = i-1)（i&gt;0,集合第一个序号为0，故需要-1）,序号(n)的左子节点为序号(2n+1)，右子节点为序号(2n+2)。<br>　int child = 2 * parentid + 1;就是这里的特性使用。<br>　引用 <a href="https://www.cnblogs.com/0zcl/p/6737944.html" target="_blank" rel="noopener">链接</a> 中这个图比较直观。</p><p> <img src="/contentimg/2/4.1.png" alt="Result pic 4" title="堆排序图解"></p><p> 在下面的代码中是这样的：</p><p> <img src="/contentimg/2/4.2.png" alt="Result pic 5" title="堆排序实例"></p><h3 id="4-2具体代码实现"><a href="#4-2具体代码实现" class="headerlink" title="4.2具体代码实现"></a>4.2具体代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSortMethod : SortBaseClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//从parentid往下面排到length位</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">HeapAdjust</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, <span class="keyword">int</span> parentid, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> countnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = sourcelist[parentid];</span><br><span class="line">        <span class="comment">//左子节点</span></span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">2</span> * parentid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (child &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            countnum++;</span><br><span class="line">            <span class="comment">//取 左右 子节点中的较大值</span></span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt; length &amp;&amp; sourcelist[child] &lt; sourcelist[child + <span class="number">1</span>])</span><br><span class="line">                child++;</span><br><span class="line">            <span class="comment">//与父节点比较，大于父节点就得交换，否则继续下个循环</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= sourcelist[child])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            sourcelist[parentid] = sourcelist[child];</span><br><span class="line">            ConsoleOutProcess(sourcelist, parentid, child);</span><br><span class="line">            parentid = child;</span><br><span class="line">            child = <span class="number">2</span> * parentid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查是否进行过交换，并将缓存中的值赋回去</span></span><br><span class="line">        <span class="keyword">if</span> (sourcelist[parentid] != temp)</span><br><span class="line">        &#123;</span><br><span class="line">            countnum++;</span><br><span class="line">            sourcelist[parentid] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        ConsoleOutProcess(sourcelist, -<span class="number">1</span>, parentid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> countnum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IList&lt;<span class="keyword">int</span>&gt; <span class="title">HeapSort</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, <span class="keyword">int</span> top, out <span class="keyword">int</span> countnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IList&lt;<span class="keyword">int</span>&gt; topNode = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        countnum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第一遍，取出最大值，排到第一个(从倒数第二层左子节点开始排)</span></span><br><span class="line">        <span class="comment">//i--循环到顶0，排出最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sourcelist.Count / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            countnum += HeapAdjust(sourcelist, i, sourcelist.Count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主要排序过程(从最上面到最下面)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sourcelist.Count - <span class="number">1</span>; i &gt; sourcelist.Count - top; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将第一个与最后一个交换位置（最大值装入末尾）</span></span><br><span class="line">            <span class="keyword">int</span> temp = sourcelist[<span class="number">0</span>];</span><br><span class="line">            sourcelist[<span class="number">0</span>] = sourcelist[i];</span><br><span class="line">            sourcelist[i] = temp;</span><br><span class="line">            ConsoleOutProcess(sourcelist, <span class="number">0</span>, i);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            countnum++;</span><br><span class="line">            <span class="comment">//i，最后一个，是当前最大值</span></span><br><span class="line">            <span class="comment">//topNode 大根堆</span></span><br><span class="line">            topNode.Add(temp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将去掉最后一个值的集合重新排</span></span><br><span class="line">            countnum += HeapAdjust(sourcelist, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//topNode 大根堆</span></span><br><span class="line">        <span class="comment">//sourcelist 小根堆</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sourcelist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> override IList&lt;<span class="keyword">int</span>&gt; <span class="title">Sort</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, out <span class="keyword">int</span> countnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IList&lt;<span class="keyword">int</span>&gt; resultlist = sourcelist;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> HeapSort(sourcelist, sourcelist.Count, out countnum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　同时修改main函数的算法为具体的： ISortMethod sort = new HeapSortMethod();</p><p>　　执行结果为：</p><p><img src="/contentimg/2/4.3.png" alt="Result pic 6" title="堆排序"></p><h2 id="五-归并排序"><a href="#五-归并排序" class="headerlink" title="五. 归并排序"></a>五. 归并排序</h2><h3 id="5-1原理"><a href="#5-1原理" class="headerlink" title="5.1原理"></a>5.1原理</h3><p> <a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015?fr=aladdin" target="_blank" rel="noopener">归并排序</a> （Merge Sort）算法的原理如下:</p><p>　假设序列共有n个元素，将序列每相邻两个数字进行归并操作（merge)，形成floor(n/2)个序列，排序后每个序列包含两个元素。将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素…重复归并，直到所有元素排序完毕。<br>　引用 <a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">链接</a> 中这个图比较直观。</p><p> <img src="/contentimg/2/5.1.png" alt="Result pic 7" title="归并排序图解"></p><h3 id="5-2具体代码实现"><a href="#5-2具体代码实现" class="headerlink" title="5.2具体代码实现"></a>5.2具体代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public class MergeSortMethod : SortBaseClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> override IList&lt;<span class="keyword">int</span>&gt; <span class="title">Sort</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, out <span class="keyword">int</span> countnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IList&lt;<span class="keyword">int</span>&gt; resultlist = sourcelist;</span><br><span class="line">        countnum = <span class="number">0</span>;</span><br><span class="line">        DivSort(resultlist, <span class="number">0</span>, resultlist.Count - <span class="number">1</span>, ref countnum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultlist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对折拆分左右两组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DivSort</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, <span class="keyword">int</span> leftid, <span class="keyword">int</span> rightid, ref <span class="keyword">int</span> countnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftid &lt; rightid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> midid = (leftid + rightid) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//前1/2</span></span><br><span class="line">            DivSort(sourcelist, leftid, midid, ref countnum);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//后1/2</span></span><br><span class="line">            DivSort(sourcelist, midid + <span class="number">1</span>, rightid, ref countnum);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//比较排序(拆分到最后要进行的比较和合并)</span></span><br><span class="line">            Merge(sourcelist, leftid, midid, rightid, ref countnum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右坐标相等，或者左边大于右边(midid + 1)，相当于拆到最后一个，进入下一步Merge</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要排序操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, <span class="keyword">int</span> leftid, <span class="keyword">int</span> midid, <span class="keyword">int</span> rightid, ref <span class="keyword">int</span> countnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IList&lt;<span class="keyword">int</span>&gt; temp = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = leftid;</span><br><span class="line">        <span class="keyword">int</span> j = midid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= midid &amp;&amp; j &lt;= rightid)</span><br><span class="line">        &#123;</span><br><span class="line">            countnum++;</span><br><span class="line">            <span class="comment">//取最小值存入缓存</span></span><br><span class="line">            <span class="keyword">if</span> (sourcelist[i] &lt;= sourcelist[j])</span><br><span class="line">                temp.Add(sourcelist[i++]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp.Add(sourcelist[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两种情况只会存在一种：左(/右)边还有值</span></span><br><span class="line">        <span class="comment">//左边</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= rightid)</span><br><span class="line">        &#123;</span><br><span class="line">            countnum++;</span><br><span class="line">            temp.Add(sourcelist[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右边</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= midid)</span><br><span class="line">        &#123;</span><br><span class="line">            countnum++;</span><br><span class="line">            temp.Add(sourcelist[i++]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        foreach (<span class="keyword">var</span> item in temp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//leftid~midid~rightid区间为已排序，其他部分未排序</span></span><br><span class="line">            <span class="keyword">if</span> (leftid &gt; rightid) <span class="keyword">break</span>;</span><br><span class="line">            sourcelist[leftid++] = item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ConsoleOutProcess(temp, -<span class="number">1</span>, temp.Count);</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　同时修改main函数的算法为具体的： ISortMethod sort = new MergeSortMethod();</p><p>　　执行结果为：</p><p><img src="/contentimg/2/5.2.png" alt="Result pic 8" title="归并排序"></p><h2 id="六-快速排序"><a href="#六-快速排序" class="headerlink" title="六. 快速排序"></a>六. 快速排序</h2><h3 id="6-1原理"><a href="#6-1原理" class="headerlink" title="6.1原理"></a>6.1原理</h3><p> <a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842?fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&amp;fromid=2084344&amp;fr=aladdin" target="_blank" rel="noopener">快速排序</a> （Quick Sort）算法的原理如下:</p><p>　假设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面：</p><ol><li>设置两个变量i、j，排序开始的时候：i=0，j=N-1；</li><li>以第一个数组元素作为关键数据，赋值给<strong>key</strong>，即<strong>key</strong>=A[0]；</li><li>从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于<strong>key</strong>的值A[j]，将A[j]和A[i]互换；</li><li>从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于<strong>key</strong>的A[i]，将A[i]和A[j]互换；</li><li>重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于<strong>key</strong>,4中A[i]不大于<strong>key</strong>的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</li></ol><p>　引用 <a href="http://blog.51cto.com/ahalei/1365285" target="_blank" rel="noopener">链接</a> 中这个图比较直观。</p><p> <img src="/contentimg/2/6.1.png" alt="Result pic 9" title="快速排序图解"></p><h3 id="6-2具体代码实现"><a href="#6-2具体代码实现" class="headerlink" title="6.2具体代码实现"></a>6.2具体代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class QuickSortMethod : SortBaseClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> override IList&lt;<span class="keyword">int</span>&gt; <span class="title">Sort</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, out <span class="keyword">int</span> countnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IList&lt;<span class="keyword">int</span>&gt; resultlist = sourcelist;</span><br><span class="line">        countnum = <span class="number">0</span>;</span><br><span class="line">        QuickSort(resultlist, <span class="number">0</span>, resultlist.Count - <span class="number">1</span>,ref countnum);</span><br><span class="line">        <span class="keyword">return</span> resultlist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">SortUnit</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, <span class="keyword">int</span> leftid, <span class="keyword">int</span> rightid, ref <span class="keyword">int</span> countnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key = sourcelist[leftid];</span><br><span class="line">        <span class="keyword">int</span> tempid = leftid;</span><br><span class="line">        <span class="keyword">while</span> (leftid &lt; rightid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (sourcelist[rightid] &gt;= key &amp;&amp; rightid &gt; leftid)</span><br><span class="line">            &#123;</span><br><span class="line">                countnum++;</span><br><span class="line">                --rightid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sourcelist[leftid] = sourcelist[rightid];</span><br><span class="line">            ConsoleOutProcess(sourcelist, leftid, rightid);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sourcelist[leftid] &lt;= key &amp;&amp; rightid &gt; leftid)</span><br><span class="line">            &#123;</span><br><span class="line">                countnum++;</span><br><span class="line">                ++leftid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sourcelist[rightid] = sourcelist[leftid];</span><br><span class="line">            ConsoleOutProcess(sourcelist, rightid,leftid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sourcelist[leftid] = key;</span><br><span class="line">        ConsoleOutProcess(sourcelist, tempid, leftid);</span><br><span class="line">        <span class="keyword">return</span> rightid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, <span class="keyword">int</span> leftid, <span class="keyword">int</span> rightid, ref <span class="keyword">int</span> countnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftid &gt;= rightid) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> indexid = SortUnit(sourcelist, leftid, rightid, ref countnum);</span><br><span class="line">        QuickSort(sourcelist, leftid, indexid - <span class="number">1</span>,ref countnum);</span><br><span class="line">        QuickSort(sourcelist, indexid + <span class="number">1</span>, rightid, ref countnum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　同时修改main函数的算法为具体的： ISortMethod sort = new QuickSortMethod();</p><p>　　执行结果为：</p><p><img src="/contentimg/2/6.2.png" alt="Result pic 10" title="快速排序"></p><h2 id="七-希尔排序"><a href="#七-希尔排序" class="headerlink" title="七. 希尔排序"></a>七. 希尔排序</h2><h3 id="7-1原理"><a href="#7-1原理" class="headerlink" title="7.1原理"></a>7.1原理</h3><p> <a href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/3229428?fr=aladdin" target="_blank" rel="noopener">希尔排序</a> （Shell’s Sort）算法是直接插入排序算法的一种更高效的改进版本：</p><p>　假设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面：</p><p>　先取一个小于n的整数增量（一般取n/2）d1，把数组中下标间隔d1的作为一组进行组内排序；然后取第二个增量d2（d1/2）重复操作，直到增量 = 1。</p><p>　引用 <a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">链接</a> 中这个图比较直观。</p><p> <img src="/contentimg/2/7.1.png" alt="Result pic 11" title="希尔排序图解"></p><h3 id="7-2具体代码实现"><a href="#7-2具体代码实现" class="headerlink" title="7.2具体代码实现"></a>7.2具体代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class ShellsSortMethod : SortBaseClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> override IList&lt;<span class="keyword">int</span>&gt; <span class="title">Sort</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, out <span class="keyword">int</span> countnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IList&lt;<span class="keyword">int</span>&gt; resultlist = sourcelist;</span><br><span class="line">        countnum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i, j, flag, tmp, gap = sourcelist.Count;</span><br><span class="line">        <span class="keyword">while</span> (gap &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            gap = gap / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sourcelist.Count - gap; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    countnum++;</span><br><span class="line">                    j = i + gap;</span><br><span class="line">                    <span class="keyword">if</span> (sourcelist[i] &gt; sourcelist[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        tmp = sourcelist[i];</span><br><span class="line">                        sourcelist[i] = sourcelist[j];</span><br><span class="line">                        sourcelist[j] = tmp;</span><br><span class="line">                        flag = <span class="number">1</span>;</span><br><span class="line">                        ConsoleOutProcess(resultlist, j, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最后间隔为1时需要多次微调排序</span></span><br><span class="line">            <span class="keyword">while</span> (gap == <span class="number">1</span> &amp;&amp; flag != <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　同时修改main函数的算法为具体的： ISortMethod sort = new ShellsSortMethod();</p><p>　　执行结果为：</p><p><img src="/contentimg/2/7.2.png" alt="Result pic 12" title="希尔排序"></p><h2 id="八-基数排序"><a href="#八-基数排序" class="headerlink" title="八. 基数排序"></a>八. 基数排序</h2><h3 id="8-1原理"><a href="#8-1原理" class="headerlink" title="8.1原理"></a>8.1原理</h3><p> <a href="https://www.cnblogs.com/dwj411024/p/5978821.html" target="_blank" rel="noopener">基数排序</a> （Radix Sort）算法的原理如下：</p><p>　基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。它是一种稳定的排序算法。多关键字排序中有两种方法：最高位优先法(MSD)和最低位优先法（LSD）。通常用于对数的排序选择的是最低位优先法，即先对最次位关键字进行排序，再对高一位的关键字进行排序，以此类推。</p><p>　引用 <a href="https://www.cnblogs.com/dwj411024/p/5978821.html" target="_blank" rel="noopener">链接</a> 中这个图比较直观。</p><p> <img src="/contentimg/2/8.1.png" alt="Result pic 11" title="基数排序图解"></p><h3 id="8-2具体代码实现"><a href="#8-2具体代码实现" class="headerlink" title="8.2具体代码实现"></a>8.2具体代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class RadixSortMethod : SortBaseClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> override IList&lt;<span class="keyword">int</span>&gt; <span class="title">Sort</span><span class="params">(IList&lt;<span class="keyword">int</span>&gt; sourcelist, out <span class="keyword">int</span> countnum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        countnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = sourcelist[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//找到最大的数字</span></span><br><span class="line">        foreach (<span class="keyword">var</span> item in sourcelist)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (item &gt; max) max = item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分析出有多少位数</span></span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (max / <span class="number">10</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            digit++;</span><br><span class="line">            max /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digit; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>[] indexCounter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">            IList&lt;<span class="keyword">int</span>&gt; tempList = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">            foreach (<span class="keyword">var</span> item in sourcelist)</span><br><span class="line">            &#123;</span><br><span class="line">                tempList.Add(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//排桶</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt; sourcelist.Count; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> number = (sourcelist[j] % Convert.ToInt32(Math.Pow(<span class="number">10</span>, i + <span class="number">1</span>))) / Convert.ToInt32(Math.Pow(<span class="number">10</span>, i));  <span class="comment">//得出i+1位上的数</span></span><br><span class="line">                indexCounter[number]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span>[] indexBegin = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="comment">//统计数量分布,例如3，前面有多少个数，就+1放在第几位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; <span class="number">10</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                indexBegin[k] = indexBegin[k - <span class="number">1</span>] + indexCounter[k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sourcelist.Count; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> number = (sourcelist[k] % Convert.ToInt32(Math.Pow(<span class="number">10</span>, i + <span class="number">1</span>))) / Convert.ToInt32(Math.Pow(<span class="number">10</span>, i));</span><br><span class="line">                <span class="comment">//indexBegin[number]++ 指出该数字该排的序号</span></span><br><span class="line">                tempList[indexBegin[number]++] = sourcelist[k];</span><br><span class="line">            &#125;</span><br><span class="line">            sourcelist = tempList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sourcelist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　同时修改main函数的算法为具体的： ISortMethod sort = new RadixSortMethod();</p><p>　　执行结果为：</p><p><img src="/contentimg/2/8.2.png" alt="Result pic 12" title="基数排序"></p><p>　　该算法以空间换时间，不用进行数学上的比较就能进行排序。与前面几种算法有一定的区别。</p><p> 本文测试程序工程可以从git直接获取：</p><p> git代码库: <a href="https://github.com/YaojiaxinPC/hexoblog/tree/master/SortDemo" target="_blank" rel="noopener">Codes</a></p></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>感谢您的支持</div> <button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'> <span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"> <img id="wechat_qr" src="/images/wechatpay.png" alt="姚佳鑫 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"> <img id="alipay_qr" src="/images/alipay.png" alt="姚佳鑫 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/C/" rel="tag"># C#</a> <a href="/tags/数据结构/" rel="tag"># 数据结构</a> <a href="/tags/算法/" rel="tag"># 算法</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/10/12/1IoDHSingleton/" rel="next" title="单例模式_静态构造函数实现和IoDH实现"><i class="fa fa-chevron-left"></i> 单例模式_静态构造函数实现和IoDH实现</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2018/10/15/5Closure/" rel="prev" title="闭包Closure">闭包Closure<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/contentimg/headpic.jpg" alt="姚佳鑫"><p class="site-author-name" itemprop="name">姚佳鑫</p><p class="site-description motion-element" itemprop="description">Record My Coding life.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">19</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">13</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">32</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/YaojiaxinPC" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="/images/wechataddfriend.png" target="_blank" title="WeChat"><i class="fa fa-fw fa-globe"></i> WeChat</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础代码实现："><span class="nav-number">1.</span> <span class="nav-text">基础代码实现：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-抽象公共接口部分"><span class="nav-number">1.1.</span> <span class="nav-text">1.抽象公共接口部分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-建立公共基类进行数据有效性校验和控制台输出的颜色标记"><span class="nav-number">1.1.1.</span> <span class="nav-text">2.建立公共基类进行数据有效性校验和控制台输出的颜色标记</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-main函数具体打印代码"><span class="nav-number">1.1.2.</span> <span class="nav-text">3.main函数具体打印代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-具体算法实现部分"><span class="nav-number">1.1.3.</span> <span class="nav-text">4.具体算法实现部分</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一-冒泡排序"><span class="nav-number">2.</span> <span class="nav-text">一. 冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1原理"><span class="nav-number">2.1.</span> <span class="nav-text">1.1原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2具体代码实现"><span class="nav-number">2.2.</span> <span class="nav-text">1.2具体代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-选择排序"><span class="nav-number">3.</span> <span class="nav-text">二.选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1原理"><span class="nav-number">3.1.</span> <span class="nav-text">2.1原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2具体代码实现"><span class="nav-number">3.2.</span> <span class="nav-text">2.2具体代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-插入排序"><span class="nav-number">4.</span> <span class="nav-text">三. 插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1原理"><span class="nav-number">4.1.</span> <span class="nav-text">3.1原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2具体代码实现"><span class="nav-number">4.2.</span> <span class="nav-text">3.2具体代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-堆排序"><span class="nav-number">5.</span> <span class="nav-text">四. 堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1原理"><span class="nav-number">5.1.</span> <span class="nav-text">4.1原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2具体代码实现"><span class="nav-number">5.2.</span> <span class="nav-text">4.2具体代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-归并排序"><span class="nav-number">6.</span> <span class="nav-text">五. 归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1原理"><span class="nav-number">6.1.</span> <span class="nav-text">5.1原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2具体代码实现"><span class="nav-number">6.2.</span> <span class="nav-text">5.2具体代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六-快速排序"><span class="nav-number">7.</span> <span class="nav-text">六. 快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1原理"><span class="nav-number">7.1.</span> <span class="nav-text">6.1原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2具体代码实现"><span class="nav-number">7.2.</span> <span class="nav-text">6.2具体代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七-希尔排序"><span class="nav-number">8.</span> <span class="nav-text">七. 希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1原理"><span class="nav-number">8.1.</span> <span class="nav-text">7.1原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2具体代码实现"><span class="nav-number">8.2.</span> <span class="nav-text">7.2具体代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八-基数排序"><span class="nav-number">9.</span> <span class="nav-text">八. 基数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1原理"><span class="nav-number">9.1.</span> <span class="nav-text">8.1原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2具体代码实现"><span class="nav-number">9.2.</span> <span class="nav-text">8.2具体代码实现</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">姚佳鑫</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: true,
        notify: true,
        appId: 'MKSSliaXY1yJfNdREDKmugjN-gzGzoHsz',
        appKey: 'JXNiobIr2wdnlcGKbKeKAUlP',
        placeholder: 'ʕ̢̣̣̣̣̩̩̩̩·͡˔·ོɁ̡̣̣̣̣̩̩̩̩',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("MKSSliaXY1yJfNdREDKmugjN-gzGzoHsz","JXNiobIr2wdnlcGKbKeKAUlP")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script></body></html>